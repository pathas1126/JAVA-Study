# 200203

# 앞으로의 진도

1. 윈도우(그래픽): 문법 정리목적(객체 형변환), AWT, Swing
2. **예외처리**, **입출력**, 쓰레드
3. **컬렉션 프레임워크** => **제네릭**, 열거형 => **람다**
4. TypeScript
5. **네트워크**, 소켓프로그래밍, **JDBC**

---

# Interface 인터페이스

> 클래스 혹은 프로그램이 제공하는 기능을 명시적으로 선언하는 역할

## 특징

1. 추상클래스와 동일하게 설계 목적으로 사용
2. 멤버변수: 상수만 가능, static final을 이용해서 정적 상수 선언
   (static final)을 작성하지 않아도 자동으로 설정됨
3. 추상메소드만 선언 가능, 일반메소드 사용 X ↔ 추상 클래스
   추상메소드만 사용하기 때문에 abstract 예약어 사용 X(써도 되긴 함)
4. 인터페이스 간 상속 가능
5. 인터페이스를 상속받은 자식 클래스는
   반드시 인터페이스의 추상메소드를 오버라이딩해야 함
   강제성, 통일성 부여
6. 구현된 코드가 없기 때문에 객체를 생성할 수 없음
7. 다형성을 지원하는 방법 중 하나

*※ 전체 프로그램의 설계도 역할, 둘 이상의 클래스에 통일성을 부여함*

## 추상 클래스와의 차이점

|                          인터페이스                          |      추상 클래스       |
| :----------------------------------------------------------: | :--------------------: |
| ***다중 상속 가능***<br />완전한 다중 상속 X<br />implements(구현) 필요 |    단일 상속만 가능    |
|                      추상메소드만 작성                       | 일반메소드도 사용 가능 |

※ ***implements*** : 인터페이스로부터 상속받은 추상 메소드를
클래스에서 일반 메소드로 오버라이딩해서 기능을 부여하는 것

## 형식

```java
접근 제어자 interface 인터페이스명{
    // 상수
    접근 제어자 [static final] 자료형 변수명;
    // 추상 메소드, 구현부{} X
    public [abstract] 반환형 메소드명();
}
```

## 상속 형식

### 인터페이스 → 인터페이스

```java
interface 자식 인터페이스명 extends 부모 인터페이스명 {}
```

### 클래스 → 인터페이스

```java
// 단일 상속
class 클래스명 implements 인터페이스명 {}

// 다중 상속
class 클래스명 implements 인터페이스명1, 인터페이스명2 {}
```

### 클래스 → 클래스 & 인터페이스

```java
// 클래스 하나와 여러 개의 인터페이스 상속
class 클래스명 extends 클래스명 implements 인터페이스명1, 인터페이스명2 {}
```

*※ 주요 기능은 부모 클래스에 작성해 두고 부족한 부분을 인터페이스를 상속해서 채움*

## 사용례

> 여러 개의 음향 기기에서 공통적으로 필요한 음악 재생 프로그램 설계

### Volume.java

> Volume 인터페이스 작성

```java
package j200203;
// 전체 프로그램의 설계도, 모든 클래스에서 공통으로 필요로하는 메소드 선언

public interface Volume {
	//	1. 볼륨 증가, 수정 목적(매개변수 O, 반환값 X)
	public void volumeUp(int level);
	
	// 2. 볼륨 감소
	public void volumeDown(int level);
	
	// 3, 4 turn on, turn off
	// => 자식 인터페이스에서 구현
}
```

### AdvanceVolume.java

> volume 인터페이스를 상속하는 AdvanceVolume 인터페이스 작성

```java
package j200203;

public interface AdvanceVolume extends Volume {

	// 프로그램 실행
	public void turnOn();

	// 프로그램 종료
	public void turnOff();
}


```

*※ 프로그램 규모가 커지면 하나의 인터페이스에 모든 기능을 작성할 수 없기 때문에*
*여러 개의 인터페이스로 분할해서 기능별로 관리함*

### TV.java

> AdvanceVolume 인터페이스를 상속하는 TV **클래스** 작성

```java
package j200203;

public class TV implements AdvanceVolume {
	// 멤버 변수 선언, 기본 볼륨 설정
	private int volLevel;

	// 1. 볼륨 증가 메소드 오버라이딩
	public void volumeUp(int level) {
		volLevel += level;
		System.out.println("볼륨이 " + level + "만큼 증가했습니다.");
		System.out.println("현재 볼륨: " + volLevel);
	}

	// 2. 볼륨 감소 메소드 오버라이딩
	public void volumeDown(int level) {
		if (volLevel - level < 0) {
			System.out.println("볼륨의 크기는 0보다 작을 수 없습니다!");
			System.out.println("현재 볼륨: " + volLevel);
		}
		else {
			volLevel -= level;
			System.out.println("볼륨이 " + level + "만큼 감소했습니다.");
			System.out.println("현재 볼륨: " + volLevel);
		}
	}

	// 3. 전원 켜기 메소드 오버라이딩
	public void turnOn() {
		// 전원을 켰을 때 기본 볼륨을 10으로 설정
		volLevel = 10;
		System.out.println("TV 전원이 켜졌습니다.");
	}

	// 4. 전원 끄기 메소드 오버라이딩
	public void turnOff() {
		System.out.println("TV 전원이 꺼졌습니다.");
	}
    
}
```

*※ TV 클래스와 유사한 Radio, Mp3, Speaker,,,, 등의 여러 가지 클래스를*
*간단한 수정만을 통해서 유사하게 작성할 수 있음*

### VolTest.java

> TV 클래스와 그와 유사한 Radio 클래스를 객체화해서 실행

```java
package j200203;

public class VolTest {

	public static void main(String[] args) {
         // TV 클래스 객체화
		TV tv = new TV();
		tv.turnOn();
		tv.volumeUp(3);
		tv.volumeDown(5);
		tv.turnOff();
		
		System.out.println("=======================");
		
         // Radio 클래스 객체화
		Radio rd = new Radio();
		rd.turnOn();
		rd.volumeUp(5);
		rd.volumeDown(20);
		rd.turnOff();
		
		// 객체는 다 다르지만 공통으로 사용하는
         // 메소드의 형식 및 이름은 동일하며 세부적인 기능(구현부)만 다름
		// => 다형성
        
	}

}
```

## 사용례_인터페이스 & 추상 클래스 활용

> 도형(원, 사각형, 삼각형,,,)에 따른 면적을 구하고, 그림을 그리는 프로그램 작성

### Shape.java

> **추상 클래스**
> 면적을 구하는 추상 메소드 명시
> 면적 멤버 변수, 면적을 출력하는 일반 메소드 작성

```java
package j200203;

public abstract class Shape {

	// 면적을 저장할 멤버 변수, 모든 도형에 공통으로 적용
	public double res = 0.0;

	// =========== 추상 메소드 ===========
	// 원 면적 구하기, 반지름을 매개변수로 받는 메소드를 자식 클래스에서 구현
	public abstract double areaCircle(int r);

	// 직사각형
	abstract public double areaSquare(int w, int h);

	// =========== 일반 메소드 ===========
    // 면적 출력 메소드
	public void printArea() {
		System.out.println("도형의 면적은 " + res + "입니다.");
	}
}
```

### Drawable.java

> 도형을 그리는 메소드를 명시하는 **인터페이스**

```java
package j200203;

public interface Drawable {
	public void draw(); // abstract가 생략되어 있음

}
```

### ShapeTest.java

> 추상 메소드 구현(오버라이딩) 및 프로그램 실행

```java
package j200203;

// Shape 클래스와 Drawable 인터페이스 상속
public class ShapeTest extends Shape implements Drawable {

	// 원의 면적을 구하는 메소드 오버라이딩
	public double areaCircle(int r) {
		return r * r * Math.PI;
	}

	// 사각형의 면적을 구하는 메소드 오버라이딩
	public double areaSquare(int w, int h) {
		res = w * h;
		return res;
	}
	
    // 그림을 그리는 메소드 오버라이딩
	public void draw() {
		System.out.println("원, 직사각형 그림을 그립니다.");
	}

	public static void main(String[] args) {

		ShapeTest st = new ShapeTest();
        
		double ac = st.areaCircle(3);
		System.out.println("원 면적: " + ac);
        
		double sc = st.areaSquare(2, 5);
		System.out.println("사각형 면적: " + sc);
        
		st.draw();
	}
		/*
		원 면적: 28.274333882308138
		사각형 면적: 10.0
		원, 직사각형 그림을 그립니다.
		*/    	
}
```

---

# String Method(2) & Character Method

## String Method

> String 클래스 메소드

|                메소드                 |                             설명                             |
| :-----------------------------------: | :----------------------------------------------------------: |
|         *concat(String str)*          | String 클래스 일반 메소드, String객체명.concat(String str)로 사용<br />String 객체와 인자로 전달된 str 문자열을 연결해서 반환 |
| *replace(char oldChar, char newChar)* | String 클래스 일반 메소드, 객체명.replace(변경 전 문자, 변경 후 문자)로 사용<br />문자열 내의 특정 문자를 변경 후 문자로 변경해서 반환 |
|              *length()*               | String 클래스 일반 메소드, 객체명.length()로 사용<br />문자열의 길이를 반환 |
| *indexOf(String str, int fromIndex)*  | String 클래스 일반 메소드, 객체명.indexOf("찾을 문자열", 시작 인덱스)로 사용<br/>찾을 문자열에 일치하는 문자열의 인덱스를 반환,<br/>해당 문자열이 없다면 '-1'을 리턴<br/>시작 인덱스로 검색을 시작할 문자열 인덱스 설정 가능<br/>생략시 0(처음)부터 문자열을 검색 |

## Character Method

> Character 클래스 메소드

|              메소드              |                             설명                             |
| :------------------------------: | :----------------------------------------------------------: |
| *Character.isUpperCase(char ch)* | Character 클래스 정적 메소드, Character.isUpperCase('문자')로 사용<br />인자로 전달된 문자가 대문자인 경우 true반환<br />소문자인 경우 false 반환 |
| *Character.isLowerCase(char ch)* | 사용법은 위의 메소드와 동일함<br />인자로 전달된 문자가 소문자인 경우 true반환<br />대문자인 경우 false 반환 |
| *Character.toUpperCase(char ch)* |          인자로 전달된 문자를 대문자로 바꿔서 반환           |
| *Character.toLowerCase(char ch)* |          인자로 전달된 문자를 소문자로 바꿔서 반환           |
|  *Character.isLetter(char ch)*   | 인자로 전달된 char 자료형 값이 문자라면 true를 반환하고<br />그렇지 않다면(ex. 숫자인 경우) false 반환 |

## 사용례

> 입력받은 문자열의 대소문자를 바꾼 뒤 출력

```java
package j200203;

import java.util.Scanner;

public class ConvertText {

	public static void main(String[] args) {

		// 스캐너 객체 생성
		Scanner sc = new Scanner(System.in);

		// 문자열 입력 받기
		System.out.println("문자열을 입력하시오");
		String input = sc.nextLine();

		// 입력받은 문자열 각각의 문자가 담길 변수를 임의의 값으로 초기화
		char ch = 'a';

		// 결과 문자열 변수 초기화
		String output = "";

		// 문자열 각각의 문자에 대해서 대소문자를 변경
		for (int i = 0; i < input.length(); i++) {
             // 문자열의 i번째 문자를 ch 변수에 저장
			ch = input.charAt(i);
             // 문자가 소문자인 경우 대문자로 변경
			if (Character.isLowerCase(ch))
				ch = Character.toUpperCase(ch);
             // 문자가 대문자인 경우 소문자로 변경
			else if (Character.isUpperCase(ch))
				ch = Character.toLowerCase(ch);
             // 결과 문자열에 순서대로 연결
			output = output.concat(String.valueOf(ch));
		}
         // 결과 문자열 출력
		System.out.println(output);
         /*
         문자열을 입력하시오
         Hello, Hi?
         hELLO, hI?
         */
	}

}
```

*※ ASCII 코드를 활용해서 문제를 해결할 수도 있음*

---

# Graphic_Swing

> javax.swing 패키지, UI 프로그램에 사용되는 Component 모음

- 운영체제에 독립적
- 그래픽이 좋고 지원해주는 컴포넌트가 많음
- 컴포넌트가 자바로 구성됨
- 컴포넌트 용량이 가벼움
- 컴포넌트를 창에 직접 부착할 수 없고,
  Content Pane에 부착함
  JFrame객체명.getContentPane().add(부착 컴포넌트명)
  → 지금은 바로 .add()로 작성 가능

## Swing 패키지 계층구조

1. java.lang.Object
2. java.awt.Component: 컴포넌트 정보, 위치, 배경색
3. java.awt.Container: 다른 컴포넌트를 포함할 수 있는 컴포넌트 정보, Frame(창), 대화상자
4. java.awt.Window
5. java.awt.Frame
6. javax.swing.JFrame

## JFrame

> Swing 패키지의 창에 관련된 클래스

### JFrame Method

| 메소드                                         | 설명                                                         |
| ---------------------------------------------- | ------------------------------------------------------------ |
| setTitle(String title)                         | JFrame 클래스 일반 메소드, 객체명.setTitle(String)으로 사용<br />JFrame 창의 제목을 지정함 |
| setSize(int width, int height)                 | JFrame 클래스 일반 메소드, 객체명.setSize(int, int)로 사용<br />JFrame 창의 크기를 지정함 |
| setLocation(int x, int y)                      | JFrame 클래스 일반 메소드, 객체명.setLocation(int, int)로 사용<br />JFrame 창의 위치를 지정함, 기준점은 화면 좌측 상단 |
| setBounds(int x, int y, int width, int height) | JFrame 클래스 일반 메소드, 객체명.setBounds(~)로 사용<br />JFrame 창의 위치와 크기를 한 번에 지정함<br />주로 많이 쓰임 |
| setVisible(boolean b)                          | JFrame 클래스 일반 메소드, 객체명.setVisible(boolean)으로 사용<br />화면에 JFrame창을 표출할 것인지를 결정<br />기본값이 false이기 때문에 true로 설정해야 화면에 출력 가능 |
| setDefaultCloseOperation(int operation)        | JFrame 클래스 일반 메소드<br />출력된 창의 X(close)버튼을 눌렀을 때 기본적으로 실행할 메소드를 설정함<br />매개변수로는 4가지 상수가 전달될 수 있으며<br />EXIT_ON_CLOSE 상수를 전달하면 메모리 해제 후 프로그램을 정상 종료함 |
| setBackground()                                | JFrame 클래스 일반 메소드<br />JFrame 창의 배경색을 설정함<br />getContentPane()에 연결해서 사용해야 함 |
| getSize()                                      | JFrame 클래스 일반 메소드<br />JFrame 창의 크기를 반환함     |
| getBackground(Color c)                         | JFrame 클래스 일반 메소드<br />JFrame 창의 배경색을 반환함<br />매개변수로는 Color 클래스의 객체를 사용함 |
| getContentPane()                               | JFrame 클래스 일반 메소드<br />JFrame의 contentPane 객체를 반환 |

## 배치관리자

getContentPane.setLayout(): 배치관리자를 설정하는 메소드

---

# Graphic_AWT(Abstract Window Toolkit)

> java.awt 패키지, GUI 구축을 위한 클래스들의 모임

- 요즘에는 많이 사용하지 않음
  초기에 지원했던 GUI
- 운영체제의 영향을 받음, 해상도(지원되는 색상 수)
  운영체제가 사용하는 자원을 사용
- 컴포넌트 용량이 큼
- 컴포넌트 개수가 적음
- 컴포넌트를 창에 직접 부착할 수 있음
  Frame객체명.add(부착 컴포넌트명)

## Component & Container

> AWT 패키지에 포함된 클래스

- Component: 자바 AWT에서 제공하는 버튼, 체크박스 등의 윈도우 환경을 이루는 부분
- Container: 컴포넌트를 담는 그릇 역할

