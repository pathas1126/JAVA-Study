# 200210

## 앞으로의 방향

1. 쓰레드
2. 네트워크
3. JDBC
4. JSP

## Enumeration

- 배열의 값을 출력할 때 많이 사용
- 저장된 순서대로 가져올 때

## Iterator

- 저장된 순서대로 출력 X
- 책꽂이에 있는 책들을 정확한 순서대로 출력하지 않는 것처럼

---

# Generic

> Generic Programming: 어떤 값이 하나의 참조 자료형이 아닌
> 여러 참조 자료형을 사용할 수 있도록 프로그래밍하는 것

- 여러 개의 참조 자료형을 사용할 수 있도록 할 수 있고,
  특정 자료형만 사용할 수 있도록 제한할 수도 있음
- 참조 자료형이 변환될 때 이에 대한 검증을 컴파일러가 하므로 안정적임
- 컬렉션 프레임워크도 많은 부분 제너릭으로 구현

## 배경

> 컬렉션에는 모든 자료형이 Object형으로 변환되어 저장되기 때문에
> 저장된 데이터를 불러올 때 자료형을 각각 지정해주어야 하는 문제가 발생
> 따라서 처음부터 저장할 자료형을 지정함으로써 편의성을 추구

## 특징

- 특정 자료형의 값만 입력 받아서 저장, 조회, 계산, 출력을 가능하게 함
- 멤버 변수, 메소드 매개변수에도 제너릭 부여 가능
- 기본 자료형은 사용 불가
- 컬렉션에 지정된 자료형으로만 데이터 저장 가능
  컬렉션에는 객체만 저장 가능하기 때문에 클래스형 및 Wrapper 클래스만 지정 가능
- 컬렉션 내부의 데이터를 꺼내올 때 일일이 형 변환할 필요가 없어짐
  → 유지보수에 용이

## 종류

- **< T > : Type, 클래스 설계시**
- < E > : Element, List 컬렉션에 사용시
- < K, V > : Key-Value, Map 컬렉션에 사용시
- **< ? >** : **메소드 매개변수에만 사용**
  매개변수의 자료형을 < ? >로 정의하고 내부에서는
  Object(또는 해당 클래스형)를 사용해서 모든 자료형의 매개변수를 처리할 수 있음

*※ 실제로 기능에 차이가 있는 것은 아니고, 사용 위치에 따라 분류되는 것이며*
*T대신 A나 B와 같은 임의의 문자도 사용 가능**(? 제외)***

## < > 연산자

> **< >**: 다이아몬드 연산자라고 하며
> 자료형을 <> 안의 클래스형으로 지정함

```java
컬렉션<객체 종류> 컬렉션 객체명 = new 컬렉션<객체 종류>();
// Vector<String> v = new Vector(); → v 에 String 객체만 저장 가능
// 생성자() 앞의 <객체 종류> 는 생략 가능
```

*※ Map 인터페이스 구현 클래스들은 키-값 쌍으로 데이터를 관리하기 때문에*
*2개의 객체 종류 명시 < key 객체 종류1, value 객체 종류2>*

## < T > Generic 클래스

- T: 자료형 매개변수(type parameter), 어떤 자료형도 사용할 수 있음을 나타내며
  실제로 사용할 때는 하나의 자료형에 맞춰서 사용할 수 있도록 함
- T는 컴파일할 때 Object 클래스로 변환됨
- 클래스 이름을 '클래스명< T >' 로 정의하고 나중에 클래스를 사용할 때
  T 위치에 실제 사용할 자료형을 지정
- 클래스의 각 메소드에서 해당 자료형이 필요한 부분에 모두 T를 사용하여 구현
- static 변수와는 함께 사용할 수 없음
  static은 인스턴스의 제너릭 자료형이 결정되기 전에 생성되기 때문에
  static 변수의 자료형이나 static 메소드 내부 변수의 자료형으로는 T 사용 불가

### Generic 클래스 구현 형식

```java
// 클래스 정의
class 클래스명<T> {
 	// 멤버 변수 선언
    T v[];
    
    // setter 메소드
    public void setV(T...v){
        this.v = v;
    }
    
    // getter 메소드
    public T[] getV(){
        return v;
    }
}
```

### 예제

#### GenericEX.java

> GenericEx 클래스를 담은 파일

```java
package j200210;

public class GenericEx<T> {

	// 멤버 변수
	// String v[]; Double v2[]; Integer v3[];
	T v[];

	// setter
	public void setV(T... n) {
		v = n;
	}

	/*
	 * public void setV(Double... n) { v2 = n; }
	 * 
	 * public void setV(Integer... n) { v3 = n; }
	 */

	// getter
	public T[] getV() {
		// v[] 출력, 확장 for문
		for (T s : v) {
			System.out.println(s);
		}
		// v[] 반환
		return v;
	}

}
```

*※ 자료형마다 멤버 변수, 메소드를 따로 만들 필요가 없어지고*
*T(type parameter)로 정의한 뒤에 객체 생성 후 메소드 호출시 자료형에 맞춰 사용*

#### GenericExMain.java

> GenericEX 클래스 객체 생성 후 메소드 호출을 위한 파일, main() 포함

```java
package j200210;

public class GenericExMain {

	public static void main(String[] args) {
		// String 자료형만 처리하는 GenericEx 클래스 객체 생성
		GenericEx<String> geStr = new GenericEx();

		// geStr 객체에서 메소드 호출
		geStr.setV("홍길동", "이순신", "세종대왕");
		geStr.getV();
        
        /*
        홍길동
        이순신
        세종대왕
        */

		// Double형만 처리하는 객체 생성
		GenericEx<Double> geDbl = new GenericEx();
		geDbl.setV(1.2, 2.4, 3.5);
		geDbl.getV();
        
        /*
        1.2
        2.4
        3.5
        */

		// Integer형만 처리하는 객체 생성
		GenericEx<Integer> geInt = new GenericEx();
		geInt.setV(1, 2, 3);
		geInt.getV();
        
        /*
        1
        2
        3
        */
	}

}
```

## < ? > 

> 메소드 매개변수의 자료형에 사용되는 제너릭

- < ? extends Object > 의 줄임 표현
- 어떤 자료형의 객체도 매개변수로 받겠다는 의미
- Unbounded WildCard라고 알려져 있음

### 예제

```java
package j200210;

import java.util.*;

public class WildTest {

	public static void main(String[] args) {
		// List는 인터페이스이기 때문에 ArrayList 생성 후 Upcasting 이용
		List<String> list = new ArrayList();
		list.add("test1");
		list.add("test2");
		list.add("test3");

        // Integer 자료형 list2 객체 생성
		List<Integer> list2 = new ArrayList();
		list2.add(1);
		list2.add(2);
		list2.add(new Integer(3));
        
        // Double형 list3 생성
		List<Double> list3 = new ArrayList();
		list3.add(10.1);
		list3.add(11.2);
		list3.add(12.3);

		// static 메소드 호출
		printData(list);
		printData(list2);
		printData(list3);
        
        /*
        test1	test2	test3
        1		2		3
        10.1	11.2	12.3
        */

	}

	// 리스트 출력 메소드
	public static void printData(List<?> list) {
		for (Object v : list) {
			System.out.println(v);
		}
	}

	/*
	 * public static void printData2(List<Integer> list) { for (Integer v : list) {
	 * System.out.println(v); } }
	 * 
	 * public static void printData3(List<Double> list) { for (Double v : list) {
	 * System.out.println(v); } }
	 */

}
```

## < T extends 클래스 >

> 상속을 이용해서 T의 자료형을 제한함

- 클래스 선언시 사용하며 인스턴스 생성시 특정 클래스를 상속받은 클래스형만
  인스턴스 내부에서 사용할 수 있도록 함
- 특정 인터페이스를 구현한 클래스만 사용하려는 경우에도 사용 가능

### < ? extends 클래스 >

> 매개변수의 자료형을 특정 클래스를 상속받은 클래스로만 제한함

### 예제

> extends의 역할은 자료형의 제한으로 동일하기 때문에
> < ? extends 클래스 >의 예제만 다룸

```java
package j200210;

import java.util.*;

// Person 상속X 클래스
class Test {
	String name;

}

// Person 클래스
class Person {
	String name;

}

// Person 상속 Man 클래스
class Man extends Person {
	// 생성자
	Man(String name) {
		this.name = name;
	}

	// name 반환 메소드
	public String toString() {
		return name.toString();
	}
}

// Person 상속 Woman 클래스
class Woman extends Person {
	Woman(String name) {
		this.name = name;
	}

	public String toString() {
		return name.toString();
	}
}

public class WildExtends {

	public static void main(String[] args) {

		// Person
		List<Person> listP = new ArrayList<Person>();
		listP.add(new Person());
		printData(listP);		// j200210.Person@15db9742

		// Man
		List<Man> listM = new ArrayList<Man>();
		listM.add(new Man("이순신"));
		listM.add(new Man("하현우"));
		listM.add(new Man("박효신"));
		printData(listM);	// 이순신	하현우	박효신

		// Woman
		List<Woman> listW = new ArrayList<Woman>();
		listW.add(new Woman("유관순"));
		listW.add(new Woman("백예린"));
		listW.add(new Woman("박정현"));
		printData(listW);	//	유관순	백예린	박정현

		// Test
		List<Test> listT = new ArrayList<Test>();
		listT.add(new Test());
//		printData(listT); → Person 클래스를 상속받지 않았기 때문에 메소드 호출 불가

	}

	// Person 클래스와 그 하위 클래스로 생성된 인스턴스만 매개변수로 전달 가능
	public static void printData(List<? extends Person> list) {
		for (Person obj : list) {
			System.out.println(obj);
		}
	}

}
```

### < ?  super 클래스 >

> 매개변수의 자료형을 특정 클래스와 그 클래스의 상위 클래스로만 제한함
>
> ***※ super는 T에 사용 불가***

### 예제

> 위의 예제와 유사하며, extends 대신 super 사용
> T에는 super의 사용이 불가함

```java
package j200210.super2;

import java.util.*;

// Person 클래스
class Person {
	String name;

	// 생성자 오버로드를 할 때는 기본 생성자를 작성해 주어야 함
	Person() {
	}

	Person(String name) {
		this.name = name;
	}

	public String toString() {
		return name;
	}
}

// Person 상속 Man 클래스
class Man extends Person {
	// 위의 예제와 동일
}

// Person 상속 Woman 클래스
class Woman extends Person {
	// 위의 예제와 동일
}

public class WildSuper {

	public static void main(String[] args) {

		// Person
		List<Person> listP = new ArrayList<Person>();
		listP.add(new Person("사람"));
		listP.add(new Person("인간"));
		printData(listP); // 사람 인간

		// Man
		List<Man> listM = new ArrayList<Man>();
		listM.add(new Man("하현우"));
		listM.add(new Man("박효신"));
		printData(listM); // 하현우 박효신

		// Woman
		List<Woman> listW = new ArrayList<Woman>();
		listW.add(new Woman("백예린"));
		listW.add(new Woman("박정현"));
//		printData(listW); → Man 클래스의 상위 클래스가 아니기 때문에 메소드 호출 불가

	}

	// Man 클래스와 그 상위 클래스로 생성된 인스턴스만 매개변수로 전달 가능
	public static void printData(List<? super Man> list) {
		for (Object obj : list) {
			System.out.println(obj);
		}
	}

}

```

---

# Thread 스레드

> 응용 프로그램 내에서 실행되는 최소 실행 단위

- 하나의 프로그램이 동시에 여러 개의 일을 수행할 수 있도록 함
- 순차적으로 동작하는 문장들의 단일 집합
- 경량 프로세스, 여러 개가 모이면 프로세스 형성
- 자바는 스레드를 지원하기 위해 java.lang.Thread 클래스 제공
- 톰캣 서버에서 쓰레드 단위로 요청을 처리함

## Thread 종류

- 사용자 정의 스레드: Thread 클래스를 상속받거나 Runnable 인터페이스를 구현해서
사용자가 직접 스레드를 생성하고 사용하는 것
- 메인 스레드: main() 메소드를 호출해서 실행하는 역할을 하는 기본 스레드

## Thread 활용 영역

1. 채팅 프로그램
2. 게임
3. 주식
4. CPU 사용 정보 출력

## Process

> 현재 실행중인 응용 프로그램의 최소 실행 단위

- foreground process: 눈으로 확인 가능한 범위에서 진행되는 프로세스
  ex) 작업 관리자의 앱(응용 프로그램) 탭에서 확인 가능한 프로세스
- background process: 응용 프로그램의 실행을 뒤에서 보조하는 프로세스
  ex) 작업 관리자의 백그라운드 프로세스에서 확인 가능

### Multi Tasking

> 컴퓨터에서 각각의 일을 전담하는 프로그램들(여러 개의 프로세스)을 동시에 실행하는 것
> 멀티 태스킹을 위해 운영체제가 취하는 방식이 멀티 프로세스 시스템

### Scheduling

> 멀티프로세스 시스템에서 각 프로세스는 동시에 실행되는 것처럼 보이지만,
> CPU가 하나이기 때문에 실행시간을 잘게 나누어 프로세스가 돌아가는데
> 이렇게 각 프로세스들이 돌아가면서 CPU를 점유하며 작업하는 것을 말함 

## Thread Class

- JDK에서 java.lang.Thread 클래스 제공
- 스레드 생성을 위해 사용

### Thread Field

| 필드(멤버 변수)            | 설명                                    |
| -------------------------- | --------------------------------------- |
| *static int MAX_PRIORITY*  | 스레드가 가질 수 있는 최대 우선순위, 10 |
| *static int MIN_PRIORITY*  | 스레드가 가질 수 있는 최소 우선순위, 1  |
| *static int NORM_PRIORITY* | 스레드에 할당된 기본 우선순위, 5        |

*※ 우선순위가 높을수록 상대적으로 더 많은 작업 시간을 할당함*

### Thread  주요 생성자

| 생성자                                 | 설명                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| *Thread(String name)*                  | 스레드의 이름을 name으로 설정하면서 Thread 객체 생성                               |
| *Thread(Runnable target)*              | Runnable 구현 클래스로 생성한 객체를 target으로 전달해서 Thread 객체 생성 |
| *Thread(Runnable target, String name)* | Runnable 구현 클래스로 생성한 객체를 target으로 전달해서 Thread 객체 생성<br />Thread 이름은 name으로 설정 |

### Thread Method

| 메소드                              | 설명                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| *Thread currentThread()*            | 현재 실행중인 스레드 객체를 반환하는 정적 메소드             |
| *String getName()*                  | 스레드 객체의 이름을 반환                                    |
| *long getId()*                      | 스레드 객체의 ID 값 반환                                     |
| *void setName(String name)*         | 현재 스레드 객체의 이름을 name 값으로 변경                   |
| *void run()*                        | Thread 클래스를 상속받는 클래스에서 오버라이딩해야 하는 메소드<br />해당 스레드가 실행해야할 코드를 run() 내부에 작성<br />시스템 내부(운영체제)에서 호출하는 Callback 메소드이기 때문에 직접적으로 호출하면 안됨<br />main Thread를 멈춘 상태에서 다른 쓰레드 가동(성능 저하) |
| *void start()*                      | 해당 스레드가 실행되도록 하는 메소드<br />JVM이 run() 메소드를 호출함, main Thread를 유지하면서 가동 |
| *void sleep(long millis)*           | 현재 실행 중인 스레드가 지정 밀리초만큼 잠들도록(중지) 함<br />InterruptedException 예외를 처리해야 함<br />1초 = 1000 밀리초 |
| *void setPriority(int newPriority)* | 현재 스레드의 우선순위를 newPriority로 변경함                |
| *final int getPriority()*           | 현재 스레드의 우선순위 반환                                  |

## Thread Life Cycle

> Thread는 생성 ~ 소멸까지 생명주기(Life Cycle)를 가짐

1. Thread 객체 생성
2. start() 호출 → run() 호출
3. 실행 상태 ↔ 실행 가능 상태
4. ↔ sleep() 등으로 대기 상태
   요즘엔 sleep() 외에는 거의 사용하지 않는다고 함
5. 완료

## Thread 생성 ①_Thread 클래스 상속 (권장)

1. Thread 클래스 상속: start() 메소드를 사용하기 위함
2. run() 메소드 작성: 스레드가 실행할 기능 작성
3. 스레드 객체 생성
4. start() 메소드로 스레드 실행

### 예제

```java
import java.lang.Thread;

public class MultiThread extends Thread {

	// 생성자
	public MultiThread(String s) {
		// 부모 생성자 호출
		super(s);
	}

	// Thread 클래스를 상속받아서 run() 구현
	public void run() { // 실시간으로 데이터 출력, 저장, 계산 etc.
		// a ~ z까지 출력하는 반복문
		for (char i = 'a'; i <= 'z'; i++) {
			// sleep() 메소드를 사용하기 위해 try~catch문으로 예외 처리
			try {
				// 스레드가 2초 중지하도록 함
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			System.out.println(i);
			System.out.println("현재 실행중인 스레드: " + this.getName());
		}
	}

	public static void main(String[] args) {
		// MultiThread 스레드 객체 생성, 스레드 이름을 TEST로 설정
		MultiThread mt = new MultiThread("TEST");

		// 스레드 객체 실행
		mt.start();
        
		/* a
		현재 실행중인 스레드: TEST
		b
		현재 실행중인 스레드: TEST
		...
		*/
	}

}
```

## Thread 생성 ②_Runnable 인터페이스 구현

> ※ Thread 클래스를 상속하는 것이 가장 좋지만
> 다른 클래스를 상속받아야 하는 경우
> 다중 상속이 불가능하기 때문에 Runnable 인터페이스를 구현


1. Runnable 인터페이스 구현 클래스 작성
2. Thread 클래스 객체 생성
3. Thread 클래스 객체 생성시, 생성자의 인자로 Runnable 구현 클래스 전달
4. Thread 객체에서 start() 메소드 호출

### Runnable Method

| 메소드       | 설명                                                         |
| ------------ | ------------------------------------------------------------ |
| *void run()* | Runnable 인터페이스를 구현해서 Thread 생성시 구현해야 하는 메소드<br />해당 스레드에서 실행해야 하는 코드 작성 |

*※ Runnable 인터페이스에는 run()메소드만 존재하기 때문에 Thread 클래스를 상속받는 것이 가장 좋음*

### 예제

```java
import java.lang.Thread;

// Runnable 인터페이스 구현
public class MyThread implements Runnable {

	// run() 메소드 오버라이딩
	public void run() {
		while (5 > 1) {
			// "is Running!" 출력
			System.out.println("is Running!");
			try {
				// 스레드가 1초간 정지하도록 함
				Thread.sleep(1000);
				// 현재 실행중인 스레드의 이름 출력
				System.out.println(Thread.currentThread().getName());
			} catch (Exception e) {
				System.out.println(e);
			}
		}
	}

	public static void main(String[] args) {
		// Runnable 구현 클래스 객체 생성
		MyThread mt = new MyThread();

		// Runnable 구현 클래스 객체를 이용해서 Thread 클래스 객체 생성, Thread 이름은 "Test"
		Thread tt = new Thread(mt, "Test");

		// tt 객체 실행
		tt.start();
        
        /*
        is Running!
        Test
        ....
        */

		// Runnable 구현 클래스 객체 실행, start() 메소드가 없음
		mt.run();
        
        /*
        is Running!
        main
        */

	}

}
```

## Multi Thread 다중 스레드

> 하나의 프로세스(프로그램)에 둘 이상의 스레드를 생성해서 실행
>
> 스레드는 서로 경쟁적으로 실행됨

### 장점

- 하나의 프로그램으로 동시에 여러 작업 수행 가능
  동기화: 데이터를 공유해서 작업하므로 시스템을 효율적으로 사용 가능
- 메모리 공유로 인한 시스템 자원 소모 감소

### 단점

- 서로 자원을 소모하다가 충돌할 가능성 존재
- 코딩이 난해해져 버그 발생 확률이 높아짐

### 예제

```java
import java.lang.Thread;

// 첫 번째 스레드
class PrintThread extends Thread {

	public void run() {
		// sleep() 사용을 위한 예외 처리
		try {
			// 1부터 9까지의 수 출력
			for (int i = 1; i < 10; i++) {

				/*
				 스레드를 1~1000 밀리초만큼 무작위로 중지시킴,
				 Math.random(): 0 ~ 0.999999... 사이의 난수 반환
				 */
				long sleepTime = (long) Math.ceil(Math.random() * 1000);
                 // 스레드 대기 시간 출력
				System.out.println(sleepTime);

				// 임의의 시간만큼 스레드를 중지시킴
				this.sleep(sleepTime);
				System.out.println("i: " + i);
			}
		} catch (Exception e) {
			System.out.println(e);
		}
	}
}

// 두 번째 스레드, 구구단 출력
class GuguThread implements Runnable {

	// 단을 입력 받을 멤버 변수
	int dan;

	// 생성자
	public GuguThread(int dan) {
		this.dan = dan;
	}

	// 99단 출력 run() 메소드
	public void run() {
		for (int i = 1; i <= 9; i++) {
			System.out.println(dan + "X" + i + "= " + (dan * i));
			// 단을 하나씩 출력할 때마다 500밀리초씩 스레드를 중지시킴
			try {
				Thread.sleep(500);
			} catch (Exception e) {
				System.out.println(e);
			}
		}

	}
}

public class MultiThread2 {

	public static void main(String[] args) {
		// Runnable 구현 클래스 객체 생성
		GuguThread gu = new GuguThread(5);

		// gu 스레드 객체를 이용해서 Thread 객체 생성
		Thread gugu = new Thread(gu, "GUGU");

		// Thread 상속 클래스 객체 생성
		PrintThread pt = new PrintThread();

		// 스레드별 우선순위 설정
		gugu.setPriority(1);
		pt.setPriority(Thread.MAX_PRIORITY);

		// 스레드 실행
		gugu.start(); pt.start();
        
        /*
        5X1= 5
        727
        5X2= 10
        i: 1
        36
        i: 2
        985
        5X3= 15
        ...
        */
	}

}
```

*※ 두 스레드는 서로 경쟁적으로 실행되기 때문에 결과가 섞여서 출력됨*
*우선순위는 pt 스레드가 더 높지만 먼저 끝나는 스레드를 확정할 수는 없음*