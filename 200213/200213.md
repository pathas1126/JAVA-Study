# 200213

---

# JDBC

> Java Database Connectivity
> 자바에서 Database에 접속할 수 있도록 제공하는 API

## JDBC 개요

- 자바 어플리케이션에서 표준화된 데이터베이스 접근 제공
- 각 데이터베이스 접속에 대한 상세한 정보를 알 필요 없음
  java.sql 패키지에 DB에 관련된 거의 모든 것이 인터페이스로 구성되어 있음
  즉, 데이터베이스는 달라도 같은 이름의 메소드를 사용하게 됨
- DB에 맞는 JDBC Driver 필요
- 과정: 웹에서 DB 요청 → jsp → JDBC api → JDBC Driver → DB

## JDBC API

- DB에 대해서 적절한 처리를 할 수 있도록 설계된 인터페이스 및 클래스 집합
- java.sql 패키지에서 제공되므로 import 해야 함

## JDBC Driver

- 특정 DB와 통신하기 위해 어플리케이션 서버와 DB를 연결하는 것
- 4종류의 타입이 존재함

| type | Driver 종류        | 설명                                                         |
| ---- | ------------------ | ------------------------------------------------------------ |
| 1    | *Jdbc-ODBC Bridge* | 자바 표준 API에서 제공하는 ODBC Driver 이용<br />MS의 AccessDB 연동시 사용 |
| 2    | *Native-API*       | 해당 DBMS 라이브러리 API를 JDBC API로 wrapping한 형태<br />클라이언트에 해당 DB 라이브러리와 JDBC 드라이버가 같이 존재 |
| 3    | *Proxy*            | JDBC 드라이버에서 요청한 것을 중간에 DB 미들웨어를 통해서 명령 실행<br />클라이언트는 100% 자바 JDBC 드라이버 제공 |
| 4    | *Pure*             | JDBC 드라이버에서 직접 DB에 명령하는 방식<br />인트라넷 환경에 적합 |

*※ 웹페이지와 데이터베이스를 연동할 때는 주로 Pure 드라이버 사용*
*1~3번은 요즘엔 잘 사용되지 않는다고 함*

## 전체적인 과정

1. 윈도우 [서비스] 목록에서 Oracle ~Listener, ~ORCL 서비스가 가동중인지 확인
2. 자바 코드를 이용해서 DB 접속

## ① JDBC Driver Load

> 접속할 데이터베이스 드라이버를 메모리에 올림

```java
Class.forName(DRIVER_CLASS);
// Class.forName("oracle.jdbc.driver.OracleDriver");
```

*※ Class< T > 클래스, static Class< ? > forName(String className) 메소드*
*className으로 주어진 클래스와 관련된 Class 객체 반환*
*className은 패키지명.클래스명으로 이루어짐*

##  ② Connection

> DB에 사용자가 연결된 상태를 관리하는 인터페이스
>
> DB정보로 Connection 객체를 얻어와야 함

```java
Connection conn = DriverManager.getConnection(JDBC_URL, "ID", "PWD")
// JDBC_URL = "jdbc:oracle:thin:@ip주소:port번호:SID"
```

- IP 주소: 오라클이 설치된 컴퓨터의 IP 주소 혹은 도메인 이름
- 포트: 오라클에서 네트워크를 통한 접속을 처리하기 위해 실행되어 있는 리스너의 사용 포트, 기본값은 1521
- SID: 오라클 인스턴스 이름으로 MySQL에서는 DB 이름으로도 불림 ex) orcl
- url, id, pwd와 같은 민감한 정보는 .properties로 관리해야 함
- DriverManager 클래스: JDBC 드라이버 설정을 관리하는 기본 서비스 제공
- static Connnection getConnection(String url, String user, String password)
  주어진 DB 정보로 연결을 시도함

### Connection Method

| 메소드                                           | 설명                                                         |
| ------------------------------------------------ | ------------------------------------------------------------ |
| *Statement createStatement()*                    | DB로 SQL 문장을 전송하는 Statement 객체를 생성함             |
| *PreparedStatement prepareStatement(String sql)* | DB로 매개변수를 포함한 SQL 문장을 전송하는 PreparedStatement 객체를 생성 |

### java.lang.ClassNotFoundException: oracle.jdbc.driver.OracleDrive

> oracle.jdbc.driver.OracleDriver 는 외장 라이브러리이기 때문에
> 이클립스에서 직접 불러와야 함 

#### 발생 이유

1. 오타인 경우
2. 드라이버를 못 찾는 경우

#### Oracle 10g 이후 버전에서 드라이버를 못 찾는 경우

1. C:\oracle\product\11.2.0\dbhome_1\jdbc\lib 폴더에서
   ojdbc6.jar파일을 이클립스에서 불러오면 됨
2. Package Explorer에서 프로젝트 선택
   File → Properties → Java Build Path → Libraries
   → Add External JARs → ojdbc6.jar 파일 추가 → Apply → Close
3. 또는 C:\jdk1.8\jre\lib\ext 폴더에 ojdbc6.jar 파일을 복사 / 붙여넣기
   → 전역으로 설정하는 것이기 때문에 이클립스에서 불러오지 않아도 됨
4. 파일을 다른 경로에 저장한다면 classpath 환경 변수로 경로를 지정해 주어야 함

*※ Oracle 9i → jdbc14.jar*

*※ oracle.jdbc.driver.OracleDriver*
*ojdbc6.jar 파일의 압축을 풀어보면 위의 경로에 OracleDriver가 들어있음*

## ③ Statement 생성 및 Query 실행

> Statement 인터페이스이며 SQL 문장 실행을 위해 객체로 생성 해야 함

- 인터페이스이기 때문에 스스로 객체를 생성하지 못함
  Connection 인터페이스의 createStatement() 메소드 이용
- SQL 문장을 정확하게 전부 입력해야 함
- 선택 필드나 조건이 바뀌는 경우 새롭게 작성해야 함

```java
// Statement 객체 생성
Statement stmt = conn.createStatement();

// SQL문 변수
sql = "SQL문 작성";

// SQL문 실행
stmt.executeQuery(sql);		// sql이 SELECT문인 경우
stmt.executeUpdate(sql);	// sql이 그 외 DML, DDL문인 경우
```

### Statement  Method

> Statement 객체에서 SQL 문장을 전송하기 위해 사용하는 메소드

| 메소드                               | 설명                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| *ResultSet executeQuery(String sql)* | SELECT문 전송시 사용<br />쿼리 결과로 ResultSet 객체 반환    |
| *int executeUpdate(String sql)*      | INSERT, UPDATE, DELETE문 전송시 사용<br />처리된 로우 수를 정수형으로 반환<br />처리 실패시(처리 결과가 없는 경우) 0을 리턴<br />DDL문도 전송가능 하며 DDL문은 성공시에도 처리하는 로우가 없기 때문에 0을 리턴 |

## ④ PreparedStatement 생성 및 Query 실행

> PreparedStatement 인터페이스이며 SQL 문장이 미리 컴파일되어 있는 객체

- Statement 인터페이스를 상속함
  Statement와 마찬가지로 Connection 인터페이스의
  prepareStatement(String sql) 메소드를 이용해서 객체 생성
- **?**: 매개변수 부분에 작성해서 setter 메소드로 그때그때 원하는 값을 설정
  sql의 '&변수명' 치환 매개변수와 동일한 역할을 함
- Statement보다 처리 속도가 빠름

```java
// PreparedStatement 객체 생성, sql문장을 매개변수로 전달
PreparedStatement pstmt = conn.prepareStatement(sql);

// 매개변수 값 설정
pstmt.setString(parameterIndex, value);
pstmt.setInt(parameterIndex, value);

// SQL문 실행
pstmt.executeUpdate();
```

*※ PreparedStatement 역시 매개변수 없이 사용할 수 있음*

### PreparedStatement Method

> PreparedStatement의 매개변수에 값을 전달하는 setter 메소드
> 실질적인 전송을 할 때는 Statement의 SQL 문장 전송 메소드 사용

| 메소드                                         | 설명                                                         |
| ---------------------------------------------- | ------------------------------------------------------------ |
| *void setString(int parameterIndex, String x)* | parameterIndex 번째 ?(매개변수)에 x 값 전달<br />첫 번째 매개변수의 parameterindex는 1 |
| *void setInt(int parameterIndex, int x)*       | parameterIndex 번째 ?에 x 값 전달                            |

*※ 자료형별 setter 메소드가 있기 때문에 자료형에 맞는 메소드 호출*
*JDBC 드라이버가 Java 자료형을 SQL 자료형에 맞게 변환함*

*※ SQLException 예외를 처리해야 함*

## ⑤ ResultSet 결과 받기

> 인터페이스이며 DB에 쿼리 문장을 전송하면
> 일반적으로 생성되는 DB 결과 세트를 데이터 표로 나타냄 

- ResultSet은 Cursor 개념의 연결 포인터
- Cursor: 데이터 표에서 데이터를 가리키는 포인터
- 기본적으로 next() 메소드를 통해 다음 로우로 이동

```java
// Query 결과를 ResultSet 객체로 생성
ResultSet rs = pstmt.executeQuery();
```

### ResultSet Method

| 메소드                                 | 설명                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| *boolean first()*                      | Cursor를 ResultSet 객체의 첫 번째 로우로 이동<br />로우가 있다면 true, 없으면 false 반환 |
| *boolean next()*                       | Cursor를 현재 로우에서 다음 로우로 이동시킴                  |
| *boolean previous()*                   | Cursor를 이전 로우로 이동시킴                                |
| *boolean last()*                       | Cursor를 마지막 로우로 이동시킴                              |
| *String getString(String columnLabel)* | columnLabel 칼럼의 로우를 문자열로 반환                      |
| *String getString(int columnIndex)*    | columnIndex번째 칼럼의 로우를 문자열로 반환                  |
| *Int getInt(String columnLabel)*       | columnLabel 칼럼의 로우를 정수로 반환                        |
| *Int getInt(int columnIndex)*          | columnIndex 번째  칼럼의 로우를 정수로 반환                  |

*※ 자료형마다 label 또는 index 매개변수로 컬럼의 로우를 가져올 수 있지만*
*index의 경우 테이블 구조가 변화하면 값을 수정해야 하기 때문에*
*label 매개변수를 사용하는 것이 편리함*

## ⑥ 연결 해제

- Connection을 close() 해주지 않으면 사용하지 않는 연결이 유지됨
  DB 자원을 낭비하게 됨
- 생성된 객체의 역순으로 메모리를 해제함
  ResultSet, Statement, Connection 순서
- 각 객체의 close() 메소드 이용
  예외 발생 유무와 관계없이 반드시 메모리에서 해제하기 위해 finally 구문에 작성하는 것이 좋음
  단, close() 메소드 역시 SQLException 예외를 처리해야 하기 때문에
  try ~ catch ~  문을 사용해야 함

```java
finally{
    try{
        rs.close();
        stmt.close();
        conn.close();
    }
    catch(SQLException e){
        e.printStackTrace();
    }
}
```

## 예제

> 실제로 DB 접속, 테이블 생성, 데이터 입력 / 검색 / 출력, 메모리 해제 해보기

```java
package j200213;

import java.sql.*;

public class DBSelect3 {

	public static void main(String[] args) {
		// Connection 인터페이스의 객체 변수 선언
		Connection conn = null;

		// DB url 변수
		String url = "jdbc:oracle:thin:@localhost:1521:orcl";

		// SQL 문장 객체 변수
		// try~catch문 내부에 선언하면 변수로 인식을 못하는 경우가 발생
		Statement stmt = null; // 테이블 생성 SQL문장
		PreparedStatement pstmt = null; // 매개변수를 이용한 SQL 문장
		Statement stmt2 = null; // SELECT문
		ResultSet rs = null; // SELECT 결과 저장 ResultSet 변수
		String sql = ""; // SQL문 저장 변수

		// SQL 관련 메소드 사용시 SQLException 예외를 처리해야 함
		try {
			// JDBC 드라이버를 메모리에 올림
			Class.forName("oracle.jdbc.driver.OracleDriver");

			// 접속할 DB 정보로 Connection 객체 생성
			conn = DriverManager.getConnection(url, "scott", "tiger");
			System.out.println(conn);	// oracle.jdbc.driver.T4CConnection@27f8302d

			// Statement 객체 생성
			stmt = conn.createStatement();

			// 테이블 생성 SQL문장 작성
			sql = "CREATE TABLE MyTEST(name varchar2(20), age number)";

			// sql문장 실행 및 반환 값 저장
			int create = stmt.executeUpdate(sql);

			// 결과 확인
			System.out.println("테이블 생성 성공??: " + create);	// 테이블 생성 성공??: 0

			// INSERT문, 테이블에 데이터 입력
			sql = "INSERT INTO MyTEST VALUES(?, ?)";

			// SQL문장을 매개변수로 PreparedStatement 객체 생성
			pstmt = conn.prepareStatement(sql);

			// 첫 번째 매개변수(?)에 "홍길동" 전달
			pstmt.setString(1, "홍길동");

			// 두 번째 ?에 34 전달
			pstmt.setInt(2, 34);

			// INSERT문 실행 및 반환 값 저장
			int insert = pstmt.executeUpdate();

			// 결과 확인
			System.out.println("입력 데이터 개수: " + insert);	// 입력 데이터 개수: 1

			// SELECT문, 테이블 내 데이터 조회
			stmt2 = conn.createStatement();

			// Query 반환값 ResultSet 객체 반환
			rs = stmt2.executeQuery("SELECT * FROM MyTEST");

			// 각각의 데이터를 담을 변수 선언
			String name; // 이름
			int age; // 나이

			// ResultSet의 다음 로우가 있는 동안 계속 데이터 조회
			while (rs.next()) {
				// name에 "name" 컬럼 데이터 저장
				name = rs.getString("name");

				// age에 "age" 컬럼 데이터 저장
				age = rs.getInt("age");

				// 출력
				System.out.println("이름: " + name + ", 나이: " + age);		// 이름: 홍길동, 나이: 34
			}

		} catch (Exception e) {
			System.out.println(e);

			// 예외와 상관없이 메모리에서 해제하기 위해 finally문에 작성
		} finally {
			// close() 역시 예외 처리가 필요함
			try {
				// 메모리 해제
				rs.close();
				stmt2.close();
				pstmt.close();
				stmt.close();
				conn.close();

			} catch (SQLException e) {
				System.out.println(e);
			}
		}

	}

}
```

---

# Enum 열거형

> java.lang.Enum< E >
> Class Enum< E Extends Enum < E >>
>
> 연관된 상수들을 하나의 타입으로 지정할 수 있도록 하는 클래스

- 서로 관련있는 상수들을 모아서 하나의 자료형으로 선언함
- 열거형으로 선언된 순서에 따라 0부터 index 값을 가지며, 1씩 증가함
- enum 열거형으로 지정할 상수들은 전부 대문자로 선언
- 열거형 상수들을 선언한 뒤에 세미콜론(;)을 작성하지 않음
  상수("문자열")등 상수와 다른 값을 연결하는 경우에는 ; 작성
- 다른 클래스와 마찬가지로 다른 파일, 클래스 안, 클래스 밖에 선언 가능

## Enum 장점

- 코드가 단순해지며 가독성이 좋아짐
- 인스턴스 생성과 상속을 방지하여 상수값의 안정성이 보장됨
- 상수 자료형을 정의함으로써 해당 자료형 이외의 상수 값은 저장되지 못하게 함
  final로 상수를 정의하는 경우 상수이기만 하면 어떤 값으로든 초기화가 가능하지만
  상수의 자료형이 Type인 경우에는 해당 Type에 맞는 상수로만 초기화 가능
- enum 예약어를 사용하므로 열거 의도를 분명히 함

## Enum 형식

```java
접근 제어자 enum 클래스명{
    상수1, 상수2, 상수3,,,,
}
```

## Enum Method

| 메소드                 | 설명                                                         |
| ---------------------- | ------------------------------------------------------------ |
| *toString()*           | enum 상수의 이름을 반환함<br />name() 메소드도 동일한 역할을 하지만 보다 사용자 친화적인 toString()의 사용이 권장됨 |
| *ordinal()*            | enum 클래스에서 해당 상수가 선언된 위치를 반환<br />가장 앞에 선언된 상수가 0의 값을 가짐 |
| *values()*             | enum 클래스에 선언된 상수들을 enumClass[ ] 배열로 반환       |
| *valueOf(String name)* | 매개변수로 주어진 name과 얼치하는 이름을 갖는 열겨형 원소 반환 |

### 예제

```java
package j200213;

enum Album {
	FIRST, SECOND, THIRD, FOURTH
}

public class Singer {

	public String name;
	public int age;
	public Album album;

	public static void main(String[] args) {
		Singer singer = new Singer();

		singer.name = "박효신";
		singer.age = 40;
		singer.album = Album.FIRST;

		System.out.println("가수 이름: " + singer.name);	// 가수 이름: 박효신
		System.out.println("가수 나이: " + singer.age); 	// 가수 나이: 40
		System.out.println("가수 앨범: " + singer.album); 	// 가수 앨범: FIRST

		// enumClass.values(), enum 클래스에 선언된 상수들을 배열로 반환
		for (Album a : Album.values()) {
			System.out.print(a + "\t");
		}
		// FIRST SECOND THIRD FOURTH

		// 줄바꿈
		System.out.println();

		// enumClass.FINAL.ordinal(), enum 클래스에 선언된 해당 상수의 순서를 정수로 반환
		System.out.println(Album.FIRST.ordinal()); 		// 0
		System.out.println(Album.SECOND.ordinal()); 	// 1
		System.out.println(Album.THIRD.ordinal()); 		// 2
		System.out.println(Album.FOURTH.ordinal()); 	// 3

		// enumClass.valueOf(), 매개변수로 주어진 String과 열거형에서 일치하는 이름을 갖는 원소 반환
		Album al1 = Album.FIRST;
		Album al2 = Album.valueOf("FIRST");
		System.out.println(al1); // FIRST
		System.out.println(al2); // FIRST
	}

}
```

## Enum 상수를 다른 값과 연결

- 상수("연결 문자"), 상수(자료형 값) 과 같은 형태로 작성
- 해당 자료형에 맞는 private 생성자 필요
  외부 클래스에서 상속 또는 인스턴스 생성을 하지 못하도록 함
- 연결한 값을 반환해 줄 getter 메소드 필요

### 예제_상수 - 문자열 연결

> 열거형 상수와 문자열을 연결하고 출력하는 예제

```java
package j200213;

enum Song {
	// 상수("문자열") 선언
	FIRST("숨"), SECOND("야생화"), THIRD("HOME"), FOURTH("꿈");

	// 문자열이 저장될 private 상수
	final private String title;

	// 생성자, "문자열"을 매개변수로 전달해서 title 값 초기화
	private Song(String title) {
		this.title = title;
	}

	// title 반환 getter 메소드
	public String getTitle() {
		return title;
	}

}

public class Singer2 {
	public static void main(String[] args) {
		// values() 메소드로 인해 Song 타입 객체 song이 생성되면서 title 값이 초기화되고
		// getTitle() 메소드로 title을 반환할 수 있게 됨
		for (Song song : Song.values()) {
			System.out.print(song.getTitle()+"\t");
		}
		// 숨	야생화		HOME	꿈
	}
}
```

### 예제_상수 - 정수 연결

> 열거형 상수와 정수를 연결하는 예제
>
> 위의 예제와 형식은 동일하기 때문에 주석은 제거

```java
package j200213;

enum Song {
	// 상수(정수) 선언
	FIRST(1), SECOND(2), THIRD(3), FOURTH(4);

	final private int track;

	private Song(int track) {
		this.track = track;
	}

	public int getTrack() {
		return track;
	}

}

public class Singer2 {
	public static void main(String[] args) {
		for (Song song : Song.values()) {
			System.out.print(song.getTrack() + "\t");
		}
		// 1 2 3 4
	}
}
```

---

# Lambda Expression 람다식

> 자바에서 제공하는 함수형 프로그래밍 방식

- 자바 8부터 함수형 프로그래밍 지원
- Functional Programming(FP): 함수형 프로그래밍
  함수의 구현과 호출만으로 프로그램을 만들 수 있는 프로그래밍 방식
- 함수 이름이 없는 익명 함수를 만드는 것

## Lambda 문법

### 형식

```java
(매개변수) -> {실행 코드;}
```

- 메소드 이름과 반환형을 없애고 **->** 기호 사용
- 매개변수 자료형 생략 가능
- 매개변수가 하나인 경우에는 괄호 생략 가능
- 중괄호 안의 구현 부분이 한 문장인 경우 중괄호 생략 가능
- 중괄호 안의 구현부가 한 문장이더라도 return문은 중괄호 생략 불가
- 중괄호 안의 구현부가 return문 하나라면 중괄호과 return을 모두 생략하고 식만 작성

## 함수형 인터페이스

- 자바에서는 참조 변수 없이 메소드를 호출할 수 없기 때문에
  람다식 구현을 위한 함수형 인터페이스가 필요
- 람다식 구현을 위한 함수형 인터페이스를 만들고
  인터페이스에 람다식으로 구현할 메소드 선언
- 람다식은 하나의 메소드를 구현하여 인터페이스형 변수에 대입하기 때문에
  인터페이스가 두 개 이상의 메소드를 가질 수 없음
- 람다식은 익명 함수이기 때문에
  인터페이스에 메소드가 여러 개 있으면 구분이 불가능함

## @FunctionalInterface 어노테이션

- @FunctionalInterface를 사용하면 함수형 인터페이스라는 뜻
- 메소드를 하나 이상 선언하면 오류 발생
- 필수로 작성해야 하는 것은 아니지만 함수형 인터페이스를 명시적으로 표현하므로
  나중에 발생할 오류를 방지할 수 있음

### 형식

```java
@FunctionalInterface
interface 인터페이스명 {}
```

