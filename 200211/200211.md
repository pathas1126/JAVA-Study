# 200211

# RandomAccessFile

> 입출력 클래스 중 유일하게 파일 입출력을 동시에 할 수 있는 클래스

- 임의의 위치로 이동하여 자료를 읽거나 쓸 수 있음
- File Pointer: 현재 파일의 어느 위치에서 읽고 쓰는지 그 위치를 가르키는 속성
  파일 포인터의 위치가 자료를 읽거나 쓰는 위치이므로
  파일 포인터 위치를 잘 생각해서 구현해야 함
- 스트림을 생성하지 않고 간단하게 파일에 자료를 읽거나 쓸 때 사용하면 유용

## RandomAccessFile 생성자

| 생성자                                       | 설명                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| *RandomAccessFile(File file, String mode)*   | 읽고 쓸 대상인 file 객체를 지정하고<br />mode로 읽기 전용(r) 및 읽고 쓰기(rw)를 지정할 수 있음 |
| *RandomAccessFile(String file, String mode)* | 위의 생성자와 기능은 동일하며 file 객체 대신<br />파일의 경로를 문자열로 전달 받음 |

## RandomAccessFile Method

| 메소드                    | 설명                                       |
| ------------------------- | ------------------------------------------ |
| *long getFilePointer()*   | 현재 파일에서의 파일 포인터 위치를 반환 함 |
| *void writeBytes(String s)* | 파일에 s 문자열을 작성함                   |

---

# Thread #3

# Synchronization 동기화

> 하나의 자원을 여러 태스크가 사용하려고할 때
> 한 시점에서 하나의 태스크만 사용할 수 있도록 하는 것

- 쉽게 얘기하면 A, B 스레드가 한 공간에서 동시에 작업을 하려고할 때
  A 스레드의 작업이 끝날 때까지 B가 기다려주는 것(반대의 경우도 마찬가지)
- 대부분의 응용 프로그램에서 다수의 스레드가 공유할 수 있는 영역이 요구됨
- 공유하는 부분은 상호 배타적으로 사용되어야 함
- ex) 좌석 예매 시스템
  판매처가 2곳 이상일 때 동기화가 되지 않는다면
  같은 좌석을 여러 명의 사람에게 판매하는 경우가 생김
- DB연동시 많이 사용(조회, 수정, 삭제)
  트랜잭션과 연관이 있음(commit, rollback)

## Critical Section 임계 영역

- 상호배타적으로 사용되는 공유 영역
- 자바는 한 순간에 하나의 스레드만 실행하도록 하는 synchronized method 제공
- 한 스레드가 synchronized method를 수행 중이면 다른 스레드는 대기함

## synchronized 예약어

> 메소드에 Lock을 걸어서 동기화를 도와주는 예약어

### 형식 ①

> 메소드 자체에 Lock을 거는 경우

```java
접근 제어자 synchronized 반환형 메소드명(){}
```

*※ 해당 메소드를 A스레드에서 실행중이면 B스레드는 A의 작업이 끝날때 까지 대기*

### 예제

> 입출력(RandomAccessFile)과 Thread의 동기화를 활용한 예제
> RandomAccessFile: 특정위치에 접근해서 파일을 읽거나 쓰는 입출력 클래스

```java
package j200211;

import java.io.*;
import java.lang.Thread;

public class ShareTest implements Runnable {

	// RandomAccessFile 클래스형 변수 선언
	RandomAccessFile raf = null;

	public ShareTest() {
		try {
			// 파일 생성, 읽기/쓰기가 가능하도록 rw 모드로 설정
			raf = new RandomAccessFile("result.txt", "rw");

			// Thread 객체 생성, this는 Runnable 구현 클래스인 ShareTest 클래스를 지칭
			Thread t1 = new Thread(this, "MJH");
			Thread t2 = new Thread(this, "TEST");

			// Thread 객체 실행
			t1.start();
			t2.start();

		} catch (Exception e) {
			System.out.println(e);
		}
	}

	// 동기화 → synchronized 예약어로 run() 메소드에 lock 걸기 
	public synchronized void run() {
		// writeBytes(), raf에 글자쓰기
		try {
			for (int i = 0; i < 1000; i++) {
				// Thread 명 + File Pointer 위치 + 줄바꿈(\r\n: 윈도우 운영체제 줄바꿈)
				raf.writeBytes(Thread.currentThread().getName() + "[" + i + "]" + raf.getFilePointer() + "\r\n");
			}
		} catch (Exception e) {
			System.out.println(e);
		}

	}

	public static void main(String[] args) {

		// ShareTest 객체 생성
		new ShareTest();
        /*
        MJH[0]0
        MJH[1]9
        MJH[2]18
        ....
        */
	}

}
```

*※ MJH 스레드가 작업을 전부 마친 뒤에 TEST 스레드가 작업을 시작함*

### 형식 ②

> 메소드 내부의 특정 부분에만 Lock을 거는 경우

```java
synchronized(공유 데이터){
    // Java Code;
}
```

*※ DB연동시 많이 사용하는 형식*

### 예제

> 급여계좌(공유 데이터)에서 ATM이 보험금과 공과금을 일정 금액씩 인출하는 프로그램 작성

```java
package j200211;

class ATM implements Runnable {

	// 급여계좌 잔액
	private long money = 10000;

	public void run() {
		// 동기화 → ATM 객체에 복수의 스레드가 접근할 때 서로 기다리도록 함
		synchronized (this) {
			for (int i = 0; i < 5; i++) {
				try {
					// 스레드가 1초간 대기하도록 함
					Thread.sleep(500);
				} catch (Exception e) {
					System.out.println(e);
				}
				// 잔액이 0보다 작아지면 반복문에서 탈출
				if (check() <= 0)
					break;
				// 출금
				withdraw(1000);
			}
		}
	}

	// 인출 메소드
	public void withdraw(long money) {
		// check() - money > 0 인 경우에 출금
		if (check() > money) {
			this.money -= money;
			// 현재 Thread 및 잔액 출력
			System.out.println(Thread.currentThread().getName() + ", " + check());
		} else {
			System.out.println("잔액이 부족합니다!");
		}
	}

	// 잔액 조회
	public long check() {
		return money;
	}

}

public class SyncTest {

	public static void main(String[] args) {
		// 객체를 하나만 생성해야 여러 스레드에서 하나의 데이터를 공유할 수 있음
		ATM atm = new ATM();

		// Thread 생성 및 실행
		Thread atm1 = new Thread(atm, "보헙금");
		Thread atm2 = new Thread(atm, "공과금");
		atm1.start();
		atm2.start();
        /*
        보헙금, 9000
        보헙금, 8000
        보헙금, 7000
        보헙금, 6000
        보헙금, 5000
        공과금, 4000
        공과금, 3000
        공과금, 2000
        공과금, 1000
        잔액이 부족합니다!
        */
	}

}
```

---

# Singleton Pattern 싱글톤 패턴

> 객체 지향 프로그램에서 인스턴스를 단 하나만 생성하는 디자인 패턴

- 객체를 하나만 생성한 뒤 공유해서 사용
- 웹에서 자주 사용되는 기법
  동시접속을 효율적으로 처리할 수 있음
- 메모리 절약 목적

## Design Pattern 디자인 패턴

> 객체 지향 프로그램을 어떻게 구현해야
> 좀 더 유연하고 재활용성이 높은 프로그램으로 만들 수 있는지를 정리한 내용

- 프로그램 특성에 따른 설계 유형을 이론화한 것
- 특정 알고리즘이나 프로그래밍 언어를 위한 라이브러리가 아니라
  객체 지향적으로 설계하는 방법을 설명한 것

## 싱글톤 패턴 작성법 with 예제

### 단계 ①_생성자에 private 부여

> 컴파일러가 기본 생성자를 만들지 못하게 하고
> 외부 클래스에서 임의로 해당 클래스의 인스턴스를 생성하지 못하도록 함

```java
package j200211;

public class SingTest {
	// 생성자에 private 부여
	private SingTest() {
	}

}
```



### 단계 ②_클래스 내부에 static으로 유일한 인스턴스 생성

> 프로그램 내에서 사용할 인스턴스가 하나는 필요하기 때문에
> 클래스 내부에서 인스턴스 생성 후 외부에서 접근하지 못하도록
> pivate 접근 제어자 부여

```java
package j200211;

public class SingTest {

	// 유일한 인스턴스 생성, 공유를 위해 static으로 지정
	private static SingTest st = new SingTest(); 
	
	private SingTest() {
	}

}
```



### 단계 ③_외부에서 참조할 수 있는 public 메소드 작성

> private으로 설정된 유일한 인스턴스를
> 외부에서도 사용할 수 있도록 public 메소드 작성
>
> 외부 클래스에서 해당 클래스의 인스턴스를 생성할 수 없기 때문에
> 인스턴스 반환 메소드는 반드시 static으로 선언해야 함

```java
package j200211;

public class SingTest {

	private static SingTest instance = new SingTest();

	private SingTest() {
	}

	// 외부에서 인스턴스를 참조할 수 있도록 getInstance() 메소드 작성
	public static SingTest getInstance() {
		// synchronized: 객체 참조시 작업이 중복되지 않도록 함
		synchronized (SingTest.class) {
			// instance가 없다면 instance 변수에 객체 생성
			if (instance == null) {
				instance = new SingTest();
			}
			// instance 정적 멤버 변수 반환 → 외부 참조 가능
			return instance;
		}

	}

}

```



### 단계 ④_실제 사용 코드 작성

```java
package j200211;

public class Test {

	public static void main(String[] args) {
		// 객체 생성, SingTest 클래스의 인스턴스를 반환 받음
		SingTest st1 = SingTest.getInstance();
		SingTest st2 = SingTest.getInstance();

		// 동일한 인스턴스인지 비교
		if (st1 == st2) {
			System.out.println("st1 주소: " + st1);
			System.out.println("st2 주소: " + st2);
			System.out.println("같은 인스턴스 입니다.");
		}
		/*
		st1 주소: j200211.SingTest@15db9742
		st2 주소: j200211.SingTest@15db9742
		같은 인스턴스 입니다.
         */
	}

}
```

---

# Network

> 같은 데이터 전송 프로토콜을 사용해서 통신하는 일련의 장치들을 총칭하는 것

## Protocol

> 여러 장치들이 서로 교신하기 위해 사용하는 의사소통 방식

### TCP/IP

> 컴퓨터간 대화에 필요한 통신 규약을 의미하는 프로토콜 중
> 현재 표준이 되는 프로토콜

- TCP: Transmission Control Protocol
- IP: Internet Protocol

## Network Class

> java.net 패키지에서 network와 관련된 클래스를 제공함
>
> 접속하고자 하는 경로가 실제로 존재하지 않을 수도 있기 때문에
> 반드시 예외처리를 해야함

### InetAddress

> java.net.InetAddress
> ip 정보를 가지고 있는 네트워크 클래스

#### InetAddress Method

| 메소드                                     | 설명                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| *InetAddress getByName(String host)*       | host는 도메인 주소를 사용하며 해당 host의 도메인 주소와 IP주소를 담은 InetAddress 객체 반환 |
| *InetAddress[ ] getAllByName(String host)* | host의 모든 도메인 주소/IP 주소를 담은 InetAddress 객체를 배열로 반환 |
| *InetAddress getLocalHost()*               | Local Host의 주소를 반환<br />Local Host: 현재 사용 중인 컴퓨터 |
| *String getHostAddress()*                  | InetAddress 객체에 담긴 IP주소를 String으로 반환             |
| *String getHostName()*                     | 해당 InetAddress 객체에 담긴 host 이름 반환                  |

#### 예제

```java
package j200211;

import java.net.*; // InetAddress, Socket, ServerSocket

public class NetworkTest {

	public static void main(String[] args) throws Exception {

		// 하나의 ip 주소를 저장
		InetAddress ia = null;

		// www.daum.net의 도메인, IP 주소를 가진 객체 반환
		ia = InetAddress.getByName("www.daum.net");

		// ia 객체의 IP 주소 반환
		System.out.println(ia.getHostAddress());	// 211.231.99.80

		// 두 대 이상의 컴퓨터 주소 관리
		InetAddress ia2[];

		// www.daum.net의 모든 도메인, IP 주소 저장
		ia2 = InetAddress.getAllByName("www.daum.net");

		// 확장 for문, 출력
		for (InetAddress i : ia2) {
			System.out.println(i.getHostAddress());
		}
        /*
        211.231.99.80
        211.231.99.17
        */

		// 자기 컴퓨터 정보를 담은 객체 생성
		InetAddress host = InetAddress.getLocalHost();

		// host 이름 출력
		System.out.println(host.getHostName());	// XXX-pc

		// host IP 주소 출력
		System.out.println(host.getHostAddress());	// xxx.xxx.x.xxx
	}

}
```

### URL Class

> java.net.URL
> URL(Uniform Resource Locator): 웹 상의 자원을 가리키는 pointer
> 자원은 파일, 폴더, 쿼리와 같은 객체 등이 포함됨

#### URL 생성자

| 생성자             | 설명                                 |
| ------------------ | ------------------------------------ |
| *URL(String spec)* | spec(http://~)으로부터 URL 객체 생성 |

#### URL Method

| 메소드                     | 설명                                                         |
| -------------------------- | ------------------------------------------------------------ |
| *InputStream openStream()* | 해당 URL 객체와 연결을 생성하고 연결을 읽어들이는 InputStream 객체 반환 |

#### 예제

```java
package j200211;

import java.io.*;
import java.net.*;

public class URLTest {

	public URLTest(String s) throws Exception {
		// URl 클래스 객체 생성
		URL url = new URL(s);

		// 접속한 컴퓨터의 스트림 이용
		InputStream in = url.openStream();

		// 데이터를 가져와서 저장 후 콘솔에 출력
		String ss;
		BufferedReader br = new BufferedReader(new InputStreamReader(in));

		// 데이터를 계속 읽어들일 수 있는 상태라면 콘솔에 출력
		while ((ss = br.readLine()) != null) {
			System.out.println(ss);
			// 파일에 출력: FileOutputStream, FileWriter
		}

		// 스트림 사용 후 메모리 해제
		in.close();
		br.close();
	}

	public static void main(String[] args) throws Exception {

		// URLTest 객체 생성
		URLTest ult = new URLTest("http://www.naver.com");
		/*
		<html>
		<head><title>302 Found</title></head>
		<body>
		....
		*/
	}
}
```

*※ 해당 사이트에서 차단한 경우에는 결과가 위와 같이 출력됨*
*차단하지 않은 경우에는 전체 코드 출력*

## ServerSocket & Socket Class

> java.net.[Server]Socket
> 자바에서 서버-클라이언트 프로그램 작성을 위해 제공하는 클래스

### ServerSocket

> 서버 측에서 실행되는 애플리케이션을 작성하기 위해 사용

#### ServerSocket 생성자

| 생성자                   | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| *ServerSocket(int port)* | 클라이언트 요청을 받아들일 포트(port)번호를 가지고 ServerSocket 객체 생성<br />포트 번호는 1024~49151 사이에서 몇 가지 번호를 제외하고 사용 가능|

#### ServerSocket Method

| 메소드                         | 설명                                                      |
| ------------------------------ | --------------------------------------------------------- |
| *Socket accept()*              | 클라이언트 요청을 받아서 Socket 객체 생성 후 반환         |
| *InetAddress getInetAddress()* | 현재 서버 소켓의 지역 주소 정보를 InetAddress 객체로 반환 |
| *void close()*                 | 서버 소켓을 닫음                                          |

###  Socket

> 서버로 접속할 클라이언트 프로그램에서 사용하는 클래스

#### Socket 생성자

| 생성자                               | 설명                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| *Socket(String host, int port)*      | 연결할 host(접속할 서버 IP 주소)와 port(접속 포트 번호)로 소켓 생성 |
| *Socket(InetAddress addr, int port)* | 접속할 서버의 InetAddress 객체와 port 번호로 소켓 생성       |

#### Socket Method

| 메소드                           | 설명                                              |
| -------------------------------- | ------------------------------------------------- |
| *InputStream getInputStream()*   | 현재 소켓과 관련된 InputStream 객체 반환          |
| *OutputStream getOutputStream()* | 현재 소켓과 관련된 OutputStream 객체 반환         |
| *void close()*                   | 소켓 닫기                                         |
| *InetAddress getInetAddress()*   | 소켓에 연결된 원격 컴퓨터의 InetAddress 객체 반환 |
| *InetAddress getLocalAddress()*  | 소켓에 연결된 지역 컴퓨터의 InetAddress 객체 반환 |
| *int getPort()*                  | 소켓에 연결된 컴퓨터의 포트 번호 반환             |
| *int getLocalPort()*             | 소켓에 연결된 지역 컴퓨터의 포트 번호 반환        |

### TCP 소켓 / UDP 비교

|                             TCP                              |                             UDP                              |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| 상호 연결된 상태에서 통신하는 방법이기 때문에 높은 신뢰성이 요구되는 어플리케이션에 적합 | User Datagram Protocol의 약자로 TCP 소켓에 비해 신뢰성과 안정성 측면에서 뒤떨어짐 |
| 네트워크에 부담을 주기 때문에 신뢰성이 충족되지 않거나 많은 양의 데이터를 전송하는 경우 부적합 |     연결을 설정하지 않으므로 네트워크에 부담을 주지 않음     |

---

# 채팅 프로그램 만들기

## ① 클라이언트 GUI 작성



## ② 서버 작성

## has-a 관계

| ChatGUIServer |                  | ServerThread |
| ------------- | ---------------- | ------------ |
| broadCast()   | ===============> | send()       |
|               | <=============== | run()        |

*※ 두 클래스에서 서로의 메소드를 필요로 하기 때문에 상대방의 객체를 생성해서 메소드 호출*

1. 상대 클래스 객체를 멤버 변수로 선언
2. ChatGUIServer 생성자에서 위의 멤버 변수 초기화
3. ServerThread 생성자에서 new 연산자로 ChatGUIServer 객체 생성 불가
   서버가 두 번 구동되며 그런 경우에 충돌이 일어날 수 있음
4. 따라서 ServerThread 생성자의 매개변수로 ChatGUIServer의 객체를 넘겨받아서
   ServerThread 멤버 변수 초기화
5. ChatGUIServer에서 ServerThread 객체 생성시 인자로 this(=ChatGUIServer) 전달