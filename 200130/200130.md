# 200130

---

# String Method

> 기본적으로 많이 사용되는 String 클래스 메소드 정리

| 메소드                              | 설명                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| *substring(start index)*            | String 클래스의 일반 메소드, 객체명.substring()으로 사용하며,<br />시작 인덱스부터 마지막 인덱스까지의 문자열을 추출함<br />문자열 시작 인데스: 0 |
| *substring(start index, end index)* | 시작 인덱스부터 지정한 끝 인덱스까지의 문자열을 추출하는 메소드<br />시작 인덱스의 문자는 포함되며, 끝 인덱스의 문자는 제외됨 <br />즉, 끝 인덱스 전 문자까지 문자열 추출 |
| *toUpperCase()*                     | String 클래스의 일반 메소드, 객체명.toUpperCase()로 사용하며,<br />문자열의 모든 알파벳을 대문자로 반환함 |
| *toLowerCase()*                     | 위의 메소드와 반대로 문자열의 모든 알파벳을 소문자로 반환    |
| *trim()*                            | String 클래스의 일반 메소드, 객체명.trim()으로 사용,<br />문자열 양 옆의 불필요한 공백들을 전부 제거한 문자열 반환 |
| *String.valueOf(parameter)*         | String 클래스의 정적 메소드, 매개변수로 주어진 객체의 값을 String 문자열로 반환,<br />다양한 오버로딩 를 가지고 있기 때문에 기본 자료형은 모두 매개변수로 전달 가능 |
| *charAt(index)*                     | String 클래스의 일반 메소드, 객체명.charAt()으로 사용,<br />String 문자열의 index 번째 문자를 char형으로 반환 |
| *toCharArray()*                     | String 클래스의 일반 메소드, 객체명.toCharArray()로 사용<br />String 문자열을 char형 배열 즉, char[] 형태로 반환 |

## 사용례

```java
public class ArgTestConvert {
		// String 변수 선언
		String string = "Hello, My Friend!";
		String beforeTrim = "           Hello, My Friend!           ";
		int fromInt = 1234;
    
     	 // substring(startIndex), 7번째 인덱스부터 마지막 인덱스까지 문자열 추출
		String subString1 = string.substring(7);
    
    	 // substring(startIndex, endIndex), 7번째부터 11번째 직전 문자열까지 추출
		String subString2 = string.substring(7, 11);
    
    	 // toUpperCase(), string의 모든 문자열을 대문자로 반환
		String toUpper = string.toUpperCase();
    
    	 // toLowerCase(), string의 모든 문자열을 소문자로 반환
		String toLower = string.toLowerCase();
    
    	 // trim(), beforeTrim 문자열 양 옆의 불필요한 공백 제거
		String trim = beforeTrim.trim();
    
    	 // String.valueOf(), fromInt값을 String으로 변환해서 반환 
		String valueOf = String.valueOf(fromInt);
    
    	 // charAt(), string 문자열의 4번째 문자를 char형으로 반환
    	 char charAt = string.charAt(4);
    	
    	 // toCharArray(), string 문자열을 char[]로 반환
    	 char[] ch = string.toCharArray();
    	
		
		System.out.println(subString1);		// My Friend!
		System.out.println(subString2);		// My F
		System.out.println(toUpper);		// HELLO, MY FRIEND!
		System.out.println(toLower);		// hello, my friend!
		System.out.println(trim);			// Hello, My Friend!
		System.out.println(valueOf);		// 1234
         System.out.println(charAt);		 // o
    	 System.out.println(ch);			// Hello, My Friend!
		for (int i = 0; i < 5; i++) {		// H e l l o 
			System.out.print(ch[i] + " ");
		}
	}

}
```

---

# 접근 제어자 with 상속

> 클래스, 생성자, 멤버 변수, 메소드에 외부에서의 접근 가능성을 제어하는 것

| 접근 제어자          | 설명                                                         |
| -------------------- | ------------------------------------------------------------ |
| *public*             | 외부 패키지 및 외부 클래스 어디에서나 접근 가능<br />단, 멤버 변수와 메소드가 public이더라도<br />해당 클래스가 public이 아니면 외부 패키지에서는 접근 불가<br />하나의 java(class)파일에는 하나의 public 클래스만 작성 가능 |
| *protected*          | 같은 패키지 내부와 상속 관계의 클래스에서만 접근할 수 있고 그 외 클래스에서는 접근 불가<br />외부 패키지에 있는 클래스여도 같은 패키지의 클래스를 상속받았다면 접근 가능<br />데이터를 캡슐화하면서 외부 패키지에서도 상속이 가능하도록 하는 접근 제어자 |
| *아무것도 없는 경우* | dafault이며 같은 패키지 내부에서만 접근 가능,<br />동일 패키지의 클래스를 상속받은 외부 패키지의 자식 클래스도 접근 불가<br />같은 패키지 안에서만 상속 가능 |
| *private*            | 같은 클래스 내부에서만 접근 가능하며<br />어떠한 종류의 상속도 허가하지 않음 |

*※ 최상위 클래스 선언에서는 private, protected 사용 불가*

## import

> 외부 패키지에 존재하는 클래스를 현재 클래스로 불러올 때 사용
> 같은 패키지에 있는 다른 클래스는 자동 인식(import할 필요 없음)
>
> java.lang 패키지는 기본패키지로 자동으로 import됨, **[import java.lang.*]**이 생략된 것
> 그 외 패키지는 무조건 import를 해야 사용할 수 있음

### 사용법

```java
import 최상위 패키지명.하위 패키지명.클래스명;
// import는 대체로 소스코드 가장 위쪽에 작성
// 패키지명.*; 작성시, 해당 패키지의 모든 클래스를 불러옴
```

## 사용례

> 두 개의 패키지에 세 개의 클래스를 만들어서 접근 제어자에 따른 접근 가능성에 대해 확인

### j200130.test package

#### A.java

```java
package j200130.test;

public class A {
	// Private
	private int i = 10;

	// Default
	int j;

	// Protected
	protected int k;
	
	// Public
	public int m;

	// Private, 자기 클래스 내부에서만 사용할 목적으로 만들어진 메소드에 부여
	// 외부에서 사용할 방법이 없음
	private void print() {
		System.out.println("private i: " + i);
	}

	// Default
	void print2() {
		System.out.println("default j: " + j);
	}

	// Protected
	protected void print3() {
		System.out.println("protected k: " + k);
	}
	
	// Public
	public void print4() {
		System.out.println("public m: " + m);
	}
	
	public static void main(String[] args) {

		// Public
		A a = new A();

		// Private_동일 클래스에서만 접근 가능
		System.out.println("=====private=====");
		a.i = 100;
		a.print();

		// Default_동일 패키지에서만 접근 가능
		System.out.println("=====default=====");
		a.j = 200;
		a.print2();

		// Protected
		System.out.println("=====protected=====");
		a.k = 300;
		a.print3();
		
		// Public
		System.out.println("=====public=====");
		a.m = 400;
		a.print4();
         /*
         =====private=====
         private i: 100
         =====default=====
         default j: 200
         =====protected=====
         protected k: 300
         =====public=====
         public m: 400
         */
	}

}
```

#### B.java

```java
package j200130.test;

package j200130.test;

public class B {

	public static void main(String[] args) {

		// Public_같은 패키지의 다른 클래스에서 접근 가능
		A a = new A();

		// Private_같은 패키지에서도 클래스가 다르다면 접근 불가
		System.out.println("=====private=====");
//		a.i = 100;		// is not visible : 접근이 불가능할 때 출력되는 에러
//		a.print();

		// Default_같은 패키지에서는 접근 가능
		System.out.println("=====default=====");
		a.j = 200;
		a.print2();

		// Protected_같은 패키지에서 접근 가능
		System.out.println("=====protected=====");
		a.k = 300;
		a.print3();

		// Public_같은 패키지의 다른 클래스에서 접근 가능
		System.out.println("=====public=====");
		a.m = 400;
		a.print4();
         /*
         =====private=====
         =====default=====
         default j: 200
         =====protected=====
         protected k: 300
         =====public=====
         public m: 400
         */
	}

}
```

### j200130.test2 package

#### C.java

```java
package j200130.test2;

// A 클래스가 다른 패키지에 있기 때문에 import, *을 사용하면 해당 패키지의 모든 클래스 import
import j200130.test.*;

public class C extends A {

	public static void main(String[] args) {
		// Public_외부 패키지의 다른 클래스에서도 접근 가능
		A a = new A();

		// Private_외부 클래스 및 외부 패키지에서 접근 불가
		System.out.println("=====private=====");
//		a.i = 10;
//		a.print();

		// Default_외부 패키지에서 접근 불가
		System.out.println("=====default=====");
//		a.j = 200;	
//		a.print2();
		
		// j200130.test 패키지의 A 클래스를 상속받은 C 클래스의 인스턴스로도 접근 불가
		C c = new C();
//		c.j= 300;
//		c.print2();

		// Protected_외부 패키지에서 A 클래스로 생성한 인스턴스로는 접근 불가
		System.out.println("=====protected=====");
//		a.k = 300;
//		a.print3();
		
		// j200130.test.A 클래스를 상속받은 j200130.test2.C 클래스의 인스턴스로는 접근 가능
		c.k = 300;
		c.print3();

		// Public_외부 패키지의 다른 클래스에서도 접근 가능
		System.out.println("=====public=====");
		a.m = 400;
		a.print4();

         /*
         =====private=====
         =====default=====
         =====protected=====
         protected k: 300
         =====public=====
         public m: 400
         */
	}

}
```



---

# Super

> 부모클래스의 객체를 가리키는 예약어

- super.멤버변수: 부모 클래스의 멤버 변수에 접근
- super.메소드명(~): 부모 클래스의 메소드에 접근

## super(~)

> 부모클래스 생성자 호출

- 자식클래스의 모든 생성자에 부모 클래스의 기본 생성자를 호출하는 super()가 생략되어 있음
- 매개변수 입력시, 그에 맞는 부모 클래스 생성자 호출
- 매개변수 미입력 또는 super() 생략시, 부모 클래스 기본 생성자 호출

## 상속에서의 this

> 자식클래스의 객체를 가리키는 예약어,
> 현재 생성된 객체 자체가 자식클래스이기 때문에 this가 자식클래스의 인스턴스를 가리킴

## 생성자 호출 메커니즘

> 자식클래스의 객체를 생성하면 부모클래스의 생성자를 먼저 호출한 뒤 자식클래스 생성자 호출

```java
package j200130;

// 부모 클래스
class Parent extends Object { 
    // 기본 생성자
	Parent() {
		System.out.println("부모 클래스_기본 생성자 호출");
	}
}

// 자식 클래스
class Child extends Parent {
    // 기본 생성자
	Child() {
		System.out.println("자식 클래스_기본 생성자 호출");
	}
}

public class InheriTest {

	public static void main(String[] args) {
		// Parent 클래스 pt 객체 생성, 기본 생성자 호출
		Parent pt = new Parent();
		System.out.println("pt: " + pt);
		
         // Child 클래스 cd 객체 생성, 기본 생성자 호출
		Child cd = new Child();
		System.out.println("cd: " + cd);
		
         /*
         부모 클래스_기본 생성자 호출
         pt: j200130.Parent@15db9742
         부모 클래스_기본 생성자 호출
         자식 클래스_기본 생성자 호출
         cd: j200130.Child@6d06d69c
         */
	}

}

```

*※ 상속 관계는 원래 is-a관계가 성립하도록 작성해야 하지만, 이해하기 쉽도록 간단하게 작성함*

***※ 자바에서 클래스 작성시, 기본적으로 java.lang.Object 클래스를 상속받게 되어있음***

## 사용례_Super & Overriding

```java
package j200130;

class Parent {	// extends Object 가 생략된 상태
    // 부모 클래스 멤버 변수
	String name;
	int age;
	
    // 부모 클래스 기본 생성자
	Parent() {
        super(); // 기본적으로 생략되어 있으며, Object 클래스의 기본 생성자를 호출함	
		System.out.println("부모 클래스_기본 생성자 호출");
	}

    // 생성자 오버로딩
	Parent(String name, int age) {
		this.age = age;
		this.name = name;
		System.out.println("super 생성자 호출");
	}
    
    // Object 클래스로부터 물려받은 toString()메소드 오버라이딩
	public String toString() {
		return "내용을 변경해도 되나요?";
	}
}

class Child extends Parent {
    // 자식 클래스 기본 생성자
	Child() {
         // 부모 클래스의 매개 변수가 2개인 생성자 호출
		super("홍길동", 24);
		System.out.println("자식 클래스_기본 생성자 호출");
	}
	
    // 정보 출력 일반 메소드
	void printInfo() {
		System.out.println("이름: " + name + ", 나이: " + age);
	}
}

public class InheriTest {

	public static void main(String[] args) {
		// Parent 클래스 pt 객체 생성, 기본 생성자 호출
		Parent pt = new Parent();
		System.out.println("pt.toString(): " + pt.toString());
		
         // Parent 클래스 pt 객체 생성, 기본 생성자 호출, 부모 클래스의 매개변수가 2개인 생성자 호출
		Child cd = new Child();
		System.out.println("cd.toString(): " + cd.toString());
         // 정보 출력 메소드 호출
		cd.printInfo();
         /*
         부모 클래스_기본 생성자 호출
         pt.toString(): 내용을 변경해도 되나요?
         super 생성자 호출
         자식 클래스_기본 생성자 호출
         cd.toString(): 내용을 변경해도 되나요?
         이름: 홍길동, 나이: 24
         */
	}

}
```

*※ **toString()** : Object 클래스의 일반 메소드, 객체의 주소값(문자열)을 반환하는 메소드*
*모든 클래스가 Object를 상속하기 때문에 toString() 메소드 역시 가지고 있으며,*
*객체 출력시 기본적으로 toString() 메소드가 생략된 상태로 실행됨*

*※ 부모 클래스에서 변경된 내용은 자식 클래스에도 반영됨*

## 사용례_Super

> super를 사용해서 부모 클래스의 멤버 변수와 메소드에 접근

```java
package j200130;

class Person {
	// 멤버 변수 선언
	String name; // null
	int age = 20;
	
    // 정보 출력 메소드
	void print() {
		System.out.println("Person 이름: " + name + ", 나이: " + age);
	}
}

class Man extends Person {
	// 상속받은 멤버변수와 같은 이름의 변수를 자식클래스에도 선언 가능
	int age = 40;

    // 메소드 오버라이딩
	void print() {
         // 부모 클래스인 Person 클래스의 print() 메소드 호출
		super.print();
        
         // 부모 클래스의 name, age 변수 출력
		System.out.println("Person 이름: " + super.name + ", 나이: " + super.age);
        
         // 자식 클래스의 name, age 변수 출력, 각 변수 앞에 this 생략
		System.out.println("Man 이름: " + name + ", 나이: " + age);	
	}
}

public class SuperTest2 {

	public static void main(String[] args) {
		
		// Man 클래스 m 객체 생성
		Man m = new Man();
        
		// m 객체 name 변수 초기화
		m.name = "홍길동";
        
         // m 객체의 print() 메소드 호출
		m.print();
         /*
         Person 이름: 홍길동, 나이: 20
         Person 이름: 홍길동, 나이: 20
         Man 이름: 홍길동, 나이: 40
         */
	}

}
```

---

# 예습

1. static 추가 181p ~ 190p
2. final 예약어 - 클래스, 메서드, 멤버변수 앞에 사용 가능 - 305p
3. 추상 메소드
4. 추상 클래스 281p ~ 289p 추상클래스 생성 이유?
5. 인터페이스 313p ~

