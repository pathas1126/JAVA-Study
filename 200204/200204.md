# 200204

# String Method



객체명.equalsIgnoreCase(비교 문자열)

|                  메소드                  |                             설명                             |
| :--------------------------------------: | :----------------------------------------------------------: |
| *equalsIgnoreCase(String anotherString)* | String 클래스 일반 메소드, 객체명.equalsIgnoreCase(비교 문자열)로 사용<br />대소문자를 무시하고 두 문자열을 비교해서 동일하면 true 그렇지 않다면 false 반환 |

# Character Method

|         메소드          |                             설명                             |
| :---------------------: | :----------------------------------------------------------: |
|   *isDigit(char ch)*    | 인자로 전달된 문자의 값이 숫자라면 true를 반환,<br />그렇지 않다면(ex. 문자, 공백) false 반환 |
| *isWhitespace(char ch)* | 인자로 전달된 문자의 값이 ' '공백이라면 true를 반환,<br />그렇지 않다면 false 반환 |

---

# Graphic_AWT(Abstract Window Toolkit)

> java.awt 패키지, GUI 구축을 위한 클래스들의 모임

- 요즘에는 많이 사용하지 않음
  초기에 지원했던 GUI
- 운영체제의 영향을 받음, 해상도(지원되는 색상 수)
  운영체제가 사용하는 자원을 사용
- 컴포넌트 용량이 큼
- 컴포넌트 개수가 적음
- 컴포넌트를 창에 직접 부착할 수 있음
  Frame객체명.add(부착 컴포넌트명)

## Graphic_Swing

> javax.swing 패키지, UI 프로그램에 사용되는 Component 모음

- 운영체제에 독립적
- 그래픽이 좋고 지원해주는 컴포넌트가 많음
- 컴포넌트가 자바로 구성됨
- 컴포넌트 용량이 가벼움
- 컴포넌트를 창에 직접 부착할 수 없고,
  Content Pane에 부착함
  JFrame객체명.getContentPane().add(부착 컴포넌트명)
  → 지금은 바로 .add()로 작성 가능


### JFrame

> Swing 패키지의 창에 관련된 클래스

#### JFrame 클래스 계층구조

1. java.lang.Object
2. java.awt.Component: 컴포넌트 정보, 위치, 배경색
3. java.awt.Container: 다른 컴포넌트를 포함할 수 있는 컴포넌트 정보, Frame(창), 대화상자
4. java.awt.Window
5. java.awt.Frame
6. javax.swing.JFrame

#### JFrame Method

| 메소드                                         | 설명                                                         |
| ---------------------------------------------- | ------------------------------------------------------------ |
| setTitle(String title)                         | Frame 클래스 일반 메소드, 객체명.setTitle(String)으로 사용<br />Frame 창의 제목을 지정함 |
| setSize(int width, int height)                 | Frame 클래스 일반 메소드, 객체명.setSize(int, int)로 사용<br />Frame 창의 크기를 지정함 |
| setLocation(int x, int y)                      | Frame 클래스 일반 메소드, 객체명.setLocation(int, int)로 사용<br />Frame 창의 위치를 지정함, 기준점은 화면 좌측 상단 |
| setBounds(int x, int y, int width, int height) | Frame 클래스 일반 메소드, 객체명.setBounds(~)로 사용<br />Frame 창의 위치와 크기를 한 번에 지정함<br />주로 많이 쓰임 |
| setVisible(boolean b)                          | Frame 클래스 일반 메소드, 객체명.setVisible(boolean)으로 사용<br />화면에 Frame창을 표출할 것인지를 결정<br />기본값이 false이기 때문에 true로 설정해야 화면에 출력 가능 |
| setDefaultCloseOperation(int operation)        | JFrame 클래스 일반 메소드<br />출력된 창의 X(close)버튼을 눌렀을 때 기본적으로 실행할 메소드를 설정함<br />매개변수로는 4가지 상수가 전달될 수 있으며<br />EXIT_ON_CLOSE 상수를 전달하면 메모리 해제 후 프로그램을 정상 종료함 |
| setBackground()                                | JComponent 클래스 일반 메소드<br />JComponen 창의 배경색을 설정함<br />JFrame의 경우 getContentPane()에 연결해서 사용해야 함 |
| getSize()                                      | Component 클래스 일반 메소드<br />Component의 크기를 반환함  |
| getBackground(Color c)                         | Component 클래스 일반 메소드<br />Component의 배경색을 반환함<br />매개변수로는 Color 클래스의 객체를 사용함 |
| getContentPane()                               | JFrame 클래스 일반 메소드<br />JFrame의 contentPane 객체를 반환 |

### Swing Component

| 컴포넌트   | 설명                 |
| ---------- | -------------------- |
| JButton    | 버튼                 |
| JTextField | 텍스트 입력란        |
| JTextArea  | 여러줄 텍스트 입력란 |

## Component & Container

> java.awt  패키지에 포함된 클래스

- Component: 자바 AWT에서 제공하는 버튼, 체크박스 등의 윈도우 환경을 이루는 부분
- Container: 컴포넌트를 담는 그릇 역할

## Component 생성 & 배치

1. 창을 먼저 생성
2. 만들고자 하는 컴포넌트를 멤버 변수로 선언
3. add(Component cmp) 로 창에 컴포넌트 부착
   원래는 add()앞에 getContentPane()을 작성했어야 했으나 편의상 개정됨

## Color

> java.awt 패키지에 포함된 색에 관련된 클래스

- new Color(int r, int g, int b)로 지정하거나, Color.색상명 으로 색을 지정할 수 있음
- Swing의 경우 getContentPane()에 연결해야 함

## 배치관리자

> 화면을 배치하는데 도움을 주는 클래스

| 메소드                           | 설명                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| setLayout(LayoutManager manager) | Container 클래스 일반 메소드, getContentPane().setLayout(배치관리자)로 사용 |

### BorderLayout

> Frame 내의 레이아웃을 지정하는 정적 상수
> 기본적으로 컴포넌트의 배치를 담당함

1. 경계선을 기준으로 동, 서, 남, 북, 중앙으로 배치 가능
2. [BorderLayout.위치]로 사용, "위치"로도 사용 가능
3. 위치: NORTH, WEST, SOUTH, EAST, CENTER
4. 문자열로 사용할 때는 앞 글자만 대문자로 작성, "North"

### FlowLayout

> 컨테이너 중앙에서 왼쪽부터 컴포넌트 부착
>
> 창의 크기가 부족한 경우 다음 줄에 컴포넌트 부착

1. getContentPane.setLayout(new FlowLayout())으로 사용
2. 위의 메소드 호출 후 아래 쪽에 add() 메소드로 컴포넌트를 부착하면 됨

### GridLayout

> 바둑판식으로 컴포넌트를 배치하는 방법
>
> 행/열로 표현

1. getContentPane.setLayout(new GridLayout(int rows, int cols, int hgap, int vgap))으로 사용
   매개변수로 행, 열, 컴포넌트간 수평 거리, 수직 거리를 설정할 수 있음

### 좌표값으로 배치

> setLocation(int x, int y), setBounds(int x, int y, int w, int h)로 위치 직접 설정

## EVENT

> 사용자의 조작에 따라 메소드를 호출하는 것
>
> 사용자 조작: 운영체제가 인식 가능한 사용자의 모든 행동양식
> ex) 키보드 입력, 마우스 클릭, Drag & Drop etc.

1. 이벤트 소스: UI에서 사용자의 조작에 따라 이벤트를 발생시킬 컴포넌트
2. 이벤트 발생: 사용자의 조작으로 이벤트 발생
3. 이벤트핸들러: 이벤트 발생에 따라 호출되는 메소드

### Event 종류

| 이벤트        | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| ActionEvent() | 버튼, 메뉴 항목 클릭, 글자를 입력하고 Enter 입력시 이벤트 발생 |
| MouseEvent()  | 마우스 클릭, 드래그에 따라 이벤트 발생                       |
| WindowEvent() | 창의 크기 조절, 종료                                         |
| KeyEvent()    | 키보드의 특정 키에 따라 이벤트 발생                          |

### Event Listener or Adapter

>이벤트 발생을 감지하는 인터페이스 또는 클래스

- 이벤트 종류명에서 Event 대신 Listener or Adapter를 붙여서 사용
- Listener-인터페이스, Adapter-클래스
  ex) WindowEvent -> WindowListener
  인터페이스 또는 클래스이기 때문에 상속 후 메소드를 오버라이딩해서 사용하거나
  객체를 생성(반환)해서 사용

| Listener                                                   | Adapter                           |
| ---------------------------------------------------------- | --------------------------------- |
| 불필요한 추상메소드까지 구현해야 함<br />소스코드가 늘어남 | 필요한 메소드만 오버라이딩 가능   |
| 여러 개의 이벤트처리를 동시에 구현 가능                    | 하나의 이벤트 처리밖에 할 수 없음 |

### Event Handler

> 이벤트 발생에 따라 이벤트에 대한 처리를 하는 객체 또는 메소드

### Event 처리 방법 1

> 가장 일반적인 방법이며 이벤트 리스너를
> 상속받는 클래스 자체를 이벤트 핸들러로 사용

1. 이벤트 처리를 해줄 이벤트 소스와 이벤트 결정
2. 이벤트리스너를 상속받은 클래스에서 이벤트 메소드 작성
3. 이벤트 연결: 이벤트소스.addXXXListener(이벤트 처리 객체명)
   이벤트소스와 이벤트를 처리하는 객체를 반드시 연결해주어야 함

j200204.WindowTest.java 참고

### Event 처리 방법 2

> 이벤트 발생시 이벤트를 처리하는 클래스(이벤트 리스너)를 따로 만들어서 상속

1. 이벤트 처리를 해줄 이벤트 소스와 이벤트 결정
2. 이벤트리스너를 상속받은 외부 클래스에서 이벤트 메소드 작성
3. 이벤트소스 클래스에 이벤트 처리 클래스의 객체를 생성해서 연결
   ex) addOhterListener(new Other())

j200204.WindowTest2.java 참고

### Event 처리 방법 3

> 이름이 있는 내부 클래스(Inner Class)를 이용해서 이벤트 처리
>
> 클래스는 다중 상속이 불가능하기 때문에 내부 클래스로 작성해서 사용

1. 이벤트어댑터를 상속받는 클래스를 이벤트소스 클래스의 내부에 생성
2. 외부 클래스의 addWindowListener()에 내부 클래스의 객체 연결
3. bin폴더에 외부클래스명$내부클래스명.class 파일이 생성됨

j200204.WindowTest3.java 참고

### Event 처리 방법 4

> 클래스 내부에 익명 클래스를 이용해서 이벤트 처리

1. addWindowListener() 인자로 이벤트 어댑터 클래스를 바로 객체로 생성해서 전달
2. bin폴더에 외부클래스명$번호.class 파일이 생성됨
   익명 클래스는 이름이 없기 때문에 파일명이 번호로 지정됨

---

AWT, Swing 은 현재 잘 사용되지 않기 때문에 사용되는 문법을 위주로 공부

웹 프로그래밍과 깊은 관련은 없기 때문에 포스팅은 하지 않을 예정

---

# Inner Class 내부 클래스

> 클래스 내부에 작성하는 클래스

- 내부 클래스는 외부 클래스의 접근 제어자에 상관 없이 멤버변수, 메소드에 접근 가능
- 외부 클래스에서 내부 클래스에 접근하기 위해서는 내부 클래스 객체를 생성해야 함

## 이름이 있는 내부 클래스

> 내부 클래스에 이름이 있는 경우, 일반 클래스와 동일함
> 다른 클래스의 내부에 있다는 점과 main()에서 클래스를 생성하는 방식만 다름
> 
> 외부 클래스의 멤버 변수 및 메소드에 편리하게 접근하기 위해 사용

### main() 메소드에서 내부 클래스 객체 생성법

```java
Outer클래스명.Inner클래스명 Inner객체명 = Outer객체명.new Inner클래스명()

// 외부 클래스 객체 생성
    Outer out = new Outer();
// 내부 클래스 객체 생성
	Outer.Inner in = out.new Inner();
```

### 사용례

```java
package j200204;

public class Outer {
    // 멤버 변수
    int a;

    // 생성자
    public Outer() {
        // 멤버 변수 초기화
        a = 10;
    }

    public void aa() {
        System.out.println("aa 메소드 호출");
        // 메소드 내부에서 내부 클래스 객체 생성 및 메소드 호출
        Inner in = new Inner();
        in.cc();
    }

    public void bb() {
        System.out.println("bb 메소드 호출");
    }

    // ========= Inner Class =========
    public class Inner {
        // 내부 클래스 멤버 변수
        int ax;

        // 내부 클래스 생성자
        public Inner() {
            ax = 15;
        }

        // 내부 클래스 메소드
        public void cc() {
            System.out.println("내부 클래스 cc 메소드 호출");
            System.out.println("외부 a: " + a + ", 내부 ax: " + ax);
            bb();
        }
    }

    public static void main(String[] args) {
        // Outer 클래스 객체 생성
        Outer out = new Outer();

        // main()에서 Inner 클래스 생성
        Outer.Inner oi = out.new Inner();
        
        System.out.println("==내부 클래스 멤버 변수==");
        
        // 내부 클래스 객체 oi의 멤버 변수 ax출력
        System.out.println("ax: " + oi.ax);
        
        System.out.println("====메소드 호출====");
        
        // 외부 클래스 메소드 호출
        // 메소드 호출 순서 out.aa -> in.cc -> out.bb
        out.aa();
        
         /*
         ==내부 클래스 멤버 변수==
         ax: 15
         ====메소드 호출====
         aa 메소드 호출
         내부 클래스 cc 메소드 호출
         외부 a: 10, 내부 ax: 15
         bb 메소드 호출
         */
    }

}
```

## Anonymous inner class 익명 내부 클래스

> 클래스의 이름이 없는 경우로
> 상속받은 추상클래스 또는 인터페이스를 바로 객체로 생성해서 반환함

- 단 하나의 추상 클래스 또는 단 하나의 인터페이스를 바로 생성할 수 있음
- 클래스 마지막에 세미콜론(;)을 사용해서 익명 내부 클래스가 끝났다는 것을 표현
- 인터페이스나 추상 클래스 자료형으로 변수를 선언한 후
  익명 내부 클래스를 생성해 변수에 대입할 수 있음
- 메소드 내부에 작성해서 메소드 반환형을 해당 인터페이스/추상클래스로 지정할 수도 있음
- 인터페이스와 추상 클래스 내부의 모든 추상 메소드를 반드시 오버라이딩 해야 함

### 형식

```java
new 부모 추상클래스명(){
    // 부모 추상클래스 추상 메소드 오버라이딩
};

new 부모 인터페이스명(){
    // 부모 인터페이스 메소드 오버라이딩
};
```

### 사용례

#### OuterInter.java

> OuterInter 인터페이스가 선언된 파일

```java
package j200204;

public interface OuterInter {

	public void interPrint();

}
```

#### OuterInner.java

> 추상 클래스 Abs를 선언하고
> 외부 클래스 OuterInner 내부에 추상 클래스 및 인터페이스 객체 생성

```java
package j200204;

// 추상 클래스 선언
abstract class Abs {

	// 추상 메소드
	abstract public void absPrint();

	// 일반 메소드
	public void print() {
		System.out.println("추상 클래스 일반 메소드 호출");
	}
}

// 외부 클래스
public class OuterInner {

	// 추상 클래스 상속 내부 익명 클래스 객체 생성
	// 추상 클래스를 상속했기 때문에 자료형은 추상 클래스를 따름
	Abs abs = new Abs() {
		public void absPrint() {
			System.out.println("추상 클래스 상속 내부 익명 클래스");
		}
	};

	// 인터페이스 구현 내부 익명 클래스 객체 생성
	// 인터페이스를 구현했기 때문에 자료형은 인터페이스를 따름
	OuterInter oi = new OuterInter() {
		public void interPrint() {
			System.out.println("인터페이스 구현 내부 익명 클래스 ");
		}
	};

	public static void main(String[] args) {

		// 외부 클래스 객체 생성
		OuterInner outin = new OuterInner();

		// 외부 클래스 객체에서 인터페이스 객체의 재정의된 interPrint() 메소드 호출
		outin.oi.interPrint();

		// 추상 클래스 객체의 재정의된 absPrint() 메소드 호출
		outin.abs.absPrint();

		// 추상 클래스 객체의 일반 메소드 역시 호출 가능
		outin.abs.print();
        
         /*
         인터페이스 구현 내부 익명 클래스 
         추상 클래스 상속 내부 익명 클래스
         추상 클래스 일반 메소드 호출
         */
	}

}
```

---

# 예습

1. **객체형변환**
2. instance of
3. **예외처리**
4. 입출력
5. **컬렉션**
6. 쓰레드