# 200212

---

# Socket & Thread 채팅 프로그램 만들기
> 지금까지 학습했던 거의 모든 내용이 나오는 예제
> 클라이언트끼리 실시간으로 채팅할 수 있는 프로그램 작성

## ① 클라이언트측

- 사용자가 직접 사용하는 UI 디자인
- 서버에 접속할 수 있도록 클라이언트 소켓을 생성
- 채팅은 실시간으로 이루어지기 때문에 각 클라이언트마다 스레드를 가져야 함
- 채팅 메세지는 입출력 스트림으로 서버와 송수신할 수 있도록 함

```java
package j200212;

// Socket 클래스
import java.net.*;

// 입출력 클래스
import java.io.*;

// 그래픽 관련 클래스
import java.awt.*; // GUI
import javax.swing.*; // JFrame, JTextField, JTextArea, JScrollPane

// Event 처리
import java.awt.event.*; // ActionListener

public class ChatGUIClient extends JFrame implements ActionListener, Runnable {

	// ======== GUI =========
	JTextField tf; // 전송할 텍스트 입력창
	JTextArea ta; // 전송받은 텍스트 출력

	JScrollPane js; // 스크롤바 생성

	// ======== Socket =======
	Socket s; // 서버와의 통신을 위함

	// ======== Stream =======
	BufferedReader br; // 클라이언트에서의 문자열 입력 스트림
	PrintWriter pw; // 문자열 출력 스트림

	// 서버로 전송할 문자열과 서버에서 받아올 문자열 변수
	String str, str1;

	// ======== 생성자 ========
	public ChatGUIClient() {
		// 창, 부착할 컴포넌트 생성 및 연결
		tf = new JTextField();
		ta = new JTextArea();

		// 텍스트 출력창에 스크롤 바 연결
		js = new JScrollPane(ta);
        
		// BorderLayout 배치관리자, JTextArea를 정중앙에 부착
		add(js, "Center");

		// 텍스트 필드를 하단에 부착
		add(tf, BorderLayout.SOUTH);

		// 텍스트 필드에서 이벤트(enter)를 입력받고 해당 객체에서 이벤트 처리
		tf.addActionListener(this);

		// 창 크기 지정
		setBounds(200, 200, 500, 350);

		// 창이 보이도록 설정
		setVisible(true);

		// 텍스트 필드에 커서 입력
		tf.requestFocus();

		// X버튼 클릭시 정상 종료되도록 설정
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		// 서버와 연결, 연결되지 않을 수도 있기 때문에 예외 처리 필수
		try {
			// 클라이언트 측 소켓 정보 초기화
			// Socket(host, port), host: 접속 서버 IP 주소, port: 서버 포트 번호
			s = new Socket("192.168.0.145", 5432);
			System.out.println("s>>>" + s);

			// ========== Server와 Stream 연결 ===========
			br = new BufferedReader(new InputStreamReader(s.getInputStream()));
            
            // PrintWriter 스트림의 autoFlush 기능 활성화
			pw = new PrintWriter(s.getOutputStream(), true);

		} catch (Exception e) {
			System.out.println("접속 오류>>>" + e);
		}
        
		// Thread 객체 생성, Runnable 인터페이스를 구현하기 때문에 this 작성
		Thread ct = new Thread(this);
        
        // 클라이언트 스레드 실행 → run() 호출
		ct.start();
	}

	// Runnable 인터페이스 run() 메소드 오버라이딩
	public void run() {
		// 더 이상 입력을 받을 수 없을 때까지 JTextArea(채팅창)에 출력
		try {
			while ((str1 = br.readLine()) != null) {
				ta.append(str1 + "\n"); // 상대방이 보낸 문자를 채팅창에 세로로 출력
			}
		} catch (Exception e) {
			e.printStackTrace();
			;
		}
	}

	// ActionListener 메소드 오버라이딩, 입력란에서 enter입력시 실행할 코드
	public void actionPerformed(ActionEvent e) {
		// 내가 쓴 메세지를 str 변수에 저장
		str = tf.getText();

		// 변수에 저장 후 텍스트필드 초기화
		tf.setText("");

		// 내가 쓴 메세지 출력 -> 상대방은 br.readLine()으로 읽어들임
		pw.println(str);
		pw.flush();
	}

	public static void main(String[] args) {
		
        // 클라이언트 객체 생성, 생성자 호출
		new ChatGUIClient();

	}

}
```

## ② 서버측

- 서버는 클라이언트의 요청을 처리하는 역할을 수행
- 클라이언트마다 가지고 있는 Socket과 연결할 ServerSocket 필요
- ChatGUIServer: 접속 소켓을 관리하고 전체 소켓에 메세지를 출력하는 역할
  메세지 출력 자체는 ServerThread의 send()메소드가 수행하기 때문에
  ChatGUIServer에서는 전체 소켓에 send()메소드를 호출하는 broadCast() 메소드 작성 
- ServerThread : 클라이언트의 요청을 직접적으로 처리하는 클래스
  클라이언트로부터 전송되는 메세지를 실시간으로 수신해서 출력하기 위해 스레드 상속
  클라이언트와의 직접적인 데이터 통신이 이루어짐


```java
package j200212;

import java.net.*; // ServerSocket, Socket
import java.io.*;  // 입출력

// 동적 배열, 접속한 클라이언트의 정보를 실시간으로 저장하는 목적(고정 배열X)
import java.util.Vector;

public class ChatGUIServer {

	// 클라이언트와 연결할 때만 필요한 ServerSocket 클래스
	ServerSocket ss;

	// 서버로 접속한 클라이언트 Socket을 저장할 멤버 변수
	Socket s;

	// 접속 클라이언트 정보 실시간 저장
	Vector v;

	// ServerThread 자료형 멤버 변수 선언, has-a 관계 설정을 위함
	ServerThread st;

	// 생성자, 멤버 변수 초기화
	public ChatGUIServer() {
		// 사용자 정보를 담을 v를 Vector 객체로 초기화
		v = new Vector();

		// 접속이 될 수도 있고 안 될 수도 있기 때문에 예외 처리
		try {
			// ServerSocket 객체 생성 → 포트 번호 생성(임의의 번호 부여)
			ss = new ServerSocket(5432);
			System.out.println("ss>>>" + ss);
			System.out.println("채팅 서버 가동중...");

			// 서버 가동: 클라이언트가 접속할 때까지 기다리는 것(무한 대기)
			while (true) {
				// 접속 클라이언트 Socket을 s 변수에 저장
				s = ss.accept();
				System.out.println("Accepted from" + s);

				// 접속 클라이언트와 서버로 st객체 생성
				st = new ServerThread(this, s);

				// 접속할 때마다 v에 접속 클라이언트 스레드 추가
				this.addThread(st);

				// Thread 가동 -> run() -> broadCast() -> send() 실시간 메소드 호출
				st.start();
			}

		} catch (Exception e) {
			// 접속 실패시 간단한 Error 메세지 출력
			System.out.println("서버 접속 실패>>>" + e);
		}
	}

	// 벡터 v에 접속 클라이언트의 스레드 저장
	public void addThread(ServerThread st) {
		v.add(st);
	}

	// 퇴장한 클라이언트 스레드 제거
	public void removeThread(ServerThread st) {
		v.remove(st);
	}

	// 각 클라이언트에게 메세지를 출력하는 메소드, send() 호출
	public void broadCast(String str) {
		for (int i = 0; i < v.size(); i++) {
			// 각각의 클라이언트를 ServerThread 객체로 형 변환 
			ServerThread st = (ServerThread) v.elementAt(i);
			
			// 각 스레드 객체에 str 문자열을 전송
			st.send(str);
		}
	}

	public static void main(String[] args) {

		// 익명 객체 생성
		new ChatGUIServer();

	}

}

// ServerThread 클래스 생성 → 서버에서 각 클라이언트의 요청을 처리할 스레드
class ServerThread extends Thread {

	// 클라이언트 소켓 저장
	Socket s;

	// ChatGUIServer 클래스의 객체를 멤버 변수로 선언, has-a 관계를 위함
	ChatGUIServer cg;

	// 입출력
	BufferedReader br;
	PrintWriter pw;

	// 전달할 문자열
	String str;

	// 대화명(ID)
	String name;

	// 생성자
	public ServerThread(ChatGUIServer cg, Socket s) {
		/* cg = new ChatGUIServer(); → 작성 불가, 서버가 두 번 가동되기 때문에 충돌이 일어남
		따라서 매개변수를 이용해서 객체를 얻어온(call by reference) 뒤에 cg와 s값을 초기화해야 함
		*/
		this.cg = cg;

		// 접속한 클라이언트 정보 저장
		this.s = s;

		// 데이터 전송을 위한 입출력 스트림 생성
		try {
			// =========== 입력 ===========
			// s.getInputStream() => 접속 클라이언트(소켓 객체)의 InputStream을 얻어 옴
			br = new BufferedReader(new InputStreamReader(s.getInputStream()));

			// =========== 출력 ===========
			/*
			BufferedWriter의 경우 버퍼링 기능을 가지기 때문에 PrintWriter 스트림 사용
			PrintWriter 스트림의 경우 생성자의 두 번째 인자로 autoFlush 기능을 지정할 수 있음
			BufferedWriter를 사용하는 경우 flush() 메소드를 사용해야 함
			*/
			pw = new PrintWriter(s.getOutputStream(), true);
		} catch (Exception e) {
			System.out.println("에러 발생>>>>>" + e);
		}
	}

	// 메세지(입력 문자열) 출력 메소드
	public void send(String str) {
		// 문자열 출력
		pw.println(str);

		// 혹시나 버퍼에 남아있는 것을 비워냄
		pw.flush();
	}

	// run()_ServerThread -> broadCast(str)_ChatGUIServer -> send(str)_ServerThread
	public void run() {
		try {
			// 대화명 입력 받기
			pw.println("대화명을 입력하세요");
			name = br.readLine();

			// 서버에서 각 클라이언트에 대화명 출력
			cg.broadCast("[" + name + "]" + "님이 입장했습니다.");

			// 무한 대기하며 입력한 메세지를 각 클라이언트에 계속 전달
			while ((str = br.readLine()) != null) {
				cg.broadCast("[" + name + "]: " + str);
			}
		} catch (Exception e) {
			// 접속자 퇴장시 v에서 해당 클라이언트 스레드 제거
			cg.removeThread(this); // this: ServerThread 객체, 접속 클라이언트
             // 서버에서 각 클라이언트에 출력
			cg.broadCast("[" + name + "]" + "님이 퇴장했습니다.");

			// 콘솔에 퇴장 클라이언트 IP 주소 출력
			System.out.println(s.getInetAddress() + "의 연결이 종료됨!");
		}
	}

}
```

*※ port 번호와 ip 주소 같은 민감한 정보에 대해서는 Secure Coding을 해주어야 함*

---

# Secure Coding

> 외부로부터의 해킹 소지가 있는 소스 코드의 보안을 높이는 코딩
>
> ex) DB연동: [서버 위치, 계정명, 암호, 포트 번호]등이 노출되지 않도록 해야 함

- Properties 객체 이용
- 암호화

## Properties Class

> java.util.Properties
> Map 인터페이스를 구현하며 Hashtable 컬렉션을 상속하는 하위 클래스
>
> .properties 파일을 처리하는 기능을 가진 컬렉션

- Secure Coding을 할 때 사용할 수 있는 방법 중 하나
- 컬렉션이므로 import를 해주어야 사용 가능
- 외부로부터 환경설정 파일을 불러오는 기능이 내장되어 있음
  ex) DB연동: ~.conf or .properties(주로 디폴트)

*※ Secure Coding: 외부로부터의 해킹 소지가 있는 소스 코드의 보안을 높이는 작업*

### Properties Method

| 메소드                                          | 설명                                                         |
| ----------------------------------------------- | ------------------------------------------------------------ |
| *void load(InputStream inStream)*               | 해당 스트림으로부터 key=value 리스트를 읽어 들임<br />일반적인 환경설정 파일 및 영문으로 작성된 파일을 불러올 때 사용 |
| *void list(PrintStream out)*                    | 프로퍼티 리스트를 해당 output 스트림으로 출력                |
| *String getProperty(String key)*                | 프로퍼티 리스트 중 key에 해당하는 value를 문자열로 반환      |
| *Object setProperty(String key, String value)*  | Hashtable 메소드 호출, key에 해당하는 값을 value로 설정<br />실제 파일의 값은 수정되지 않음 |
| *void store(OutputStream out, String comments)* | load() 메소드로 스트림이 연결되어 있는 Properties 테이블에 프로퍼티 리스트를 덮어씀<br />comments는 주석을 뜻하며 내용이 없으면 null 작성 |

*※ 프로퍼티 리스트에 한글이 포함되어 있는 경우에는 Input/OutputStream 대신 Reader/Writer 스트림 사용*

### .properties

> Properties 클래스로 불러오는 파일
>
> properties list를 가지고 있음

- 확장자는 .properties로 작성
- ' # ' : 한줄 주석
- Key=Value 형식으로 작성
  띄어쓰기를 하지 않는 것이 좋음

```properties
# 작성 형식
KEY1=VALUE1
KEY2=VALUE2
```

### 예제

#### ex1.properties_before

> Properties 클래스의 load() 메소드로 불러올 .properties 파일

```properties
#key value
b=imsi
a=test
```

#### PropTest.java

```java
package j200212;

import java.io.*;
import java.util.Properties;

public class PropTest {

	public static void main(String[] args) {
		// Properties 객체 생성
		Properties pro = new Properties();

		try {
			// 파일 불러오기, 입출력이므로 예외 처리 수행
			FileInputStream fis = new FileInputStream(
					"C:\\webtest\\3.java\\JAVA-Study\\200212\\src\\j200212\\ex1.properties");

			// fis 스트림으로부터 key=value 프로퍼티 리스트를 읽어 들임
			pro.load(fis);

			// 프로퍼티 리스트 출력
			System.out.println(pro);	// {b=imsi, a=test}

			// 각 key에 해당하는 value 출력
			System.out.println(pro.getProperty("a"));	// test
			System.out.println(pro.getProperty("b"));	// imsi

			// a key에 해당하는 값을 "merong"으로 설정
			pro.setProperty("a", "merong");
			System.out.println(pro.getProperty("a"));	// merong

			// 변경된 프로퍼티 리스트를 파일에 덮어 씀
			pro.store(new FileOutputStream("C:\\webtest\\3.java\\JAVA-Study\\200212\\src\\j200212\\ex1.properties"),
					"This is a comment.");

		} catch (Exception e) {
			System.out.println(e);
		}

	}

}

```

#### ex1.properties_after

> setProperty(key, value) 메소드와 store(outputStream, comments) 메소드로 수정된 파일
>
> 수정된 시간이 자동으로 생성됨

```properties
#This is a comment.
#Wed Feb 12 12:47:13 KST 2020
b=imsi
a=merong
```

---

# JDBC

> Java Database Connectivity
> 자바에서 Database에 접속할 수 있도록 제공하는 API

## JDBC 개요

- 자바 어플리케이션에서 표준화된 데이터베이스 접근 제공
- 각 데이터베이스 접속에 대한 상세한 정보를 알 필요 없음
- DB에 맞는 JDBC Driver 필요
- 과정: 웹에서 DB 요청 → jsp → JDBC api → JDBC Driver → DB

## JDBC API

- DB에 대해서 적절한 처리를 할 수 있도록 설계된 인터페이스 및 클래스 집합
- java.sql 패키지에서 제공되므로 import 해야 함

## JDBC Driver

- 특정 DB와 통신하기 위해 어플리케이션 서버와 DB를 연결하는 것
- 4종류의 타입이 존재함

| type | Driver 종류        | 설명                                                         |
| ---- | ------------------ | ------------------------------------------------------------ |
| 1    | *Jdbc-ODBC Bridge* | 자바 표준 API에서 제공하는 ODBC Driver 이용<br />MS의 AccessDB 연동시 사용 |
| 2    | *Native-API*       | 해당 DBMS 라이브러리 API를 JDBC API로 wrapping한 형태<br />클라이언트에 해당 DB 라이브러리와 JDBC 드라이버가 같이 존재 |
| 3    | *Proxy*            | JDBC 드라이버에서 요청한 것을 중간에 DB 미들웨어를 통해서 명령 실행<br />클라이언트는 100% 자바 JDBC 드라이버 제공 |
| 4    | *Pure*             | JDBC 드라이버에서 직접 DB에 명령하는 방식<br />인트라넷 환경에 적합 |

*※ 웹페이지와 데이터베이스를 연동할 때는 주로 Pure 드라이버 사용*

## 전체적인 과정

1. 윈도우 [서비스] 목록에서 Oracle ~Listener, ~ORCL 서비스가 가동중인지 확인
2. 자바 코드를 이용해서 DB 접속

## ① JDBC Driver Load

> 접속할 데이터베이스 드라이버를 메모리에 올림

```java
Class.forName(DRIVER_CLASS);
// Class.forName("oracle.jdbc.driver.OracleDriver");
```

*※ Class< T > 클래스, static Class< ? > forName(String className) 메소드*
*className으로 주어진 클래스와 관련된 Class 객체 반환*

##  ② Connection

> DB에 사용자가 연결된 상태를 관리하는 인터페이스

```java
Connection conn = DriverManager.getConnection(JDBC_URL, "ID", "PWD")
// JDBC_URL = "jdbc:oracle:thin:@ip주소:port번호:SID"
```

- IP 주소: 오라클이 설치된 컴퓨터의 IP 주소 혹은 도메인 이름
- 포트: 오라클에서 네트워크를 통한 접속을 처리하기 위해 실행되어 있는 리스너의 사용 포트, 기본값은 1521
- SID: 오라클 인스턴스 이름으로 MySQL에서는 DB 이름으로도 불림 ex) orcl
- url, id, pwd와 같은 민감한 정보는 .properties로 관리해야 함

### java.lang.ClassNotFoundException: oracle.jdbc.driver.OracleDrive

> oracle.jdbc.driver.OracleDriver 는 외장 라이브러리이기 때문에
> 이클립스에서 직접 불러와야 함 

1. 오타인 경우
2. 10g 이후 버전에서 드라이버를 못 찾는 경우
   C:\oracle\product\11.2.0\dbhome_1\jdbc\lib 폴더에서
   ojdbc6.jar(9i → jdbc14.jar)파일을 이클립스에서 불러오면 됨
3. File → Properties → Java Build Path → Libraries
   → Add External JARs → ojdbc6.jar 파일 추가 → Apply → Close

---

# 추가 사항

- FileInputStream
  int available() 메소드: 스트림으로 읽어올 수 있는 잔여 바이트 수 반환, 파일을 불러오지 못하는 경우 -1 리턴