# 200116 수업 내용 정리

---

# Operator 연산자

> 연산을 실행하는 기호
>
> ※ 피연산자 : 연산의 대상이 되는 값, 항이라고도 함

---

## 산술연산자

### 단항 산술 연산자

| 단항 산술 연산자 | 설명                                       |
| :--------------: | ------------------------------------------ |
|        +         | 양수임을 표시하는 연산자, 양수 표기시 생략 |
|        -         | 음수임을 표시하는 연산자                   |

### 이항 산술 연산자

| 이항 산술 연산자 | 설명                                     |
| :--------------: | ---------------------------------------- |
|        +         | 두 항의 값을 더함                        |
|        -         | 앞의 항에서 뒤의 항을 뺌                 |
|        *         | 두 항의 값을 곱함                        |
|        /         | 앞의 항을 뒤의 항으로 나눔               |
|        %         | 앞의 항을 뒤의 항으로 나눈 나머지를 구함 |

---

## 증감연산자

> 특정 변수의 값을 1만큼 증가시키거나 감소시키는 역할을 하는 연산자
>
> 주로 제어문에 많이 사용됨

| 단항 산술 연산자 | 설명                           |
| :--------------: | ------------------------------ |
|     ***++***     | 피연산자의 값을 1만큼 증가시킴 |
|     ***--***     | 피연산자의 값을 1만큼 감소시킴 |

- *전위연산자* : ***++(--)변수***, 변수값을 사용하기 전에 +(-)1 계산이 먼저 이루어짐
- *후위연산자* : ***변수++(--)***, 변수값을 먼저 사용하고 나서 나중에 +(-)1 계산이 이루어짐

### 사용례 1

```java
public class Op1 {
	public static void main(String[] args) {		
		int a = 4;
		int b = a++;
		int c = ++a;
		System.out.println("a값: "+a+", b값: "+b+", c값: "+c);
        // a값: 6, b값: 4, c값: 6
        /*
        ① a = 4
        ② b에 a(4)가 대입된 후 a = 4 + 1 계산이 이루어지기
        때문에 b의 값은 4가 출력
        ③ a = 5인 상태에서 a = 5 + 1 계산이 먼저 이루어지기 때문에
        a = 6이 되고, c에 a(6)이 대입돼서 변수 a, c값으로 6이 출력
        */
	}
}
```

*※ 대입연산자 오른쪽의 산술연산자가 먼저 실행되고 그 값이 변수에 저장됨*

### 사용례 2 

```java
public class Op2 {
	public static void main(String[] args) {
		int i = 8;
		
		System.out.println("i: "+i); // i: 8
		System.out.println("++i: "+(++i)); //++i: 9
		System.out.println("i++: "+(i++)); //i++: 9
		System.out.println("i: "+i); // i: 10		
         
         System.out.println("--i: "+(--i)); // --i: 9
		System.out.println("i--: "+(i--)); //i--: 9
		System.out.println("i: "+i); // i: 8
	}
}
```

### 사용례 3 - JavaScript

> JavaScript에서 증감연산자를 사용하는 것과 동일함

```javascript
var i = 8;

console.log("i: "+i); // i: 8
console.log("i++: "+(i++)); // i: 8
console.log("++i: "+(++i)); // i: 10
console.log("i: "+i); // i: 10
```

*※ 웹브라우저에 표현하고 싶으면 console.log()를 document.write()로 바꾸면 됨*

---

## 관계연산자

| 관계연산자 | 설명                                                         |
| :--------: | ------------------------------------------------------------ |
|     >      | 왼쪽 값이 오른쪽 값보다 크다면 참                            |
|     >=     | 왼쪽 값이 오른쪽 값 이상이라면 참                            |
|     <      | 왼쪽 값이 오른쪽 값보다 작다면 참                            |
|     <=     | 왼쪽 값이 오른쪽 값 이하라면 참                              |
|     !=     | 왼쪽과 오른쪽 값이 같지 않다면 참                            |
|   **==**   | 비교연산자<br />① *변수에 들어있는 **값(내용)**이 같은 지 확인할 때 사용*<br />② *참조형(class형) : **저장 위치** 비교시 사용* |

---

## 논리연산자

| 논리연산자 | 설명                                                        |
| :--------: | ----------------------------------------------------------- |
|     &      | AND, 연결된 두 항의 논리값이 모두 참이여야 참을 반환        |
|     &&     | AND, 조건평가                                               |
|     \|     | OR, 연결된 두 항의 논리값 중 어느 하나라도 참이면 참을 반환 |
|    \|\|    | OR, 조건평가                                                |
|     ^      | XOR, 연결된 두 항의 진리값이 같으면 거짓, 다르면 참 반환    |
|     !      | NOT, 뒤에 오는 항의 진리값을 반대로 바꿔서 반환             |

### 모두평가 / 조건평가

|                        모두평가                         |                           조건평가                           |
| :-----------------------------------------------------: | :----------------------------------------------------------: |
|                          &, \|                          |                           &&, \|\|                           |
| 첫 항의 결과와 상관없이 무조건 두 항 모두 계산하는 방식 | 첫 항의 결과에 따라서 두 번째항의 계산을 생략할 수도 있는 방식 |

*※ 요즘에는 크게 구분하지 않고 사용한다고 함*

### 사용례_조건평가

```java
public class Op3 {
	public static void main(String[] args) {
		boolean b = 2>3 && 5<7;
		/* 첫 항의 값이 F이면 &&연산자에 의해 두 번째 항의 값과 관련없이
		무조건 F를 반환하기 때문에 두 번째 항 계산 생략 */
	}
}
```

### 사용례_대입연산자 & 논리연산자

```java
public class Op3 {
	public static void main(String[] args) {
		int t1 = 3, t2 = 5, t3 = 7;
		boolean b1, b2, b3;
		boolean b4 = true;
		
         // >, < 관계연산자
		System.out.println("(t1>t2)?: " + (t1 > t2)); // false
		System.out.println("(t2<t3)?: " + (t2 < t3)); // true
		
         // &&, || 조건평가
		b1 = (t1 > t2) && (t2 < t3);
		System.out.println("(t1>t2) && (t2<t3): " + b1);
         // (t1>t2) && (t2<t3): false
		b2 = (t1 > t2) || (t2 < t3);
		System.out.println("(t1>t2) || (t2<t3): " + b2);
         // (t1>t2) || (t2<t3): true
		
         // !(NOT)
         b3 = !b4;
		System.out.println("!b4: " + b3);
         // !b4: false

		// &, | 모두평가
         b1 = (t1 > t2) & (t2 < t3);
		System.out.println("(t1>t2) & (t2<t3): " + b1);
         // (t1>t2) & (t2<t3): false
		b2 = (t1 > t2) | (t2 < t3);
		System.out.println("(t1>t2) | (t2<t3): " + b2);
         // (t1>t2) | (t2<t3): true
        
         // ^
         b2 = (t1 > t2) ^ (t2 < t3);
		System.out.println("(t1>t2) ^ (t2<t3): " + b2);
         // (t1>t2) ^ (t2<t3): true, 두 항의 진리값이 다르기 때문에 true
	}
}
```

## 대입연산자

> **=** : 왼쪽 변수에 오른쪽 항의 값을 대입하는 연산자

### 복합대입연산자

> 연산과 대입을 동시에 실행하는 연산자
>
> 연산자 하나로 두 개의 연산을 하기 때문에 실행 속도가 더 빠름

| 연산자 | 기능                                                    |
| :----: | ------------------------------------------------------- |
|   +=   | 두 항의 값을 더해서 왼쪽 항에 대입                      |
|   -=   | 왼쪽 항에서 오른쪽 항을 빼서 그 값을 왼쪽 항에 대입     |
|   *=   | 두 항의 값을 곱해서 왼쪽 항에 대입                      |
|   /=   | 왼쪽 항을 오른쪽 항으로 나눈 뒤 몫을 왼쪽 항에 대입     |
|   %=   | 왼쪽 항을 오른쪽 항으로 나눈 뒤 나머지를 왼쪽 항에 대입 |

*※ +=, -=의 경우 1보다 큰 수일 때 주로 사용*
*→ 증감연산자 ++, --가 있기 때문에*

#### 사용례

```java
public class Op4 {
	public static void main(String[] args) {
		int a = 5, b = 7;
        
		// +=
		a += b;
		System.out.println("a: " + a); // a: 12
        
		// -=
		a -= b;
		System.out.println("a: " + a); // a: 5
        
		// *=
		a *= b;
		System.out.println("a: " + a); // a: 35
        
		// /=
		a /= b;
		System.out.println("a: " + a); // a: 5
        
		// %=
		a %= b;
		System.out.println("a: " + a); // a: 5
	}
}
```

*※ /(나누기) 연산의 결과 값에 소수점이 있다면 버려짐*
*→ 기본연산자가 정수 자료형인 int이기 때문에*

## 삼항연산자_조건연산자

> ***(조건식) ? 결과1 : 결과2;***
>
> 조건식의 진리값이 참이면 결과1을 선택하고
> 진리값이 거짓이면 결과2를 선택

### 사용례

```java
public class Op4 {
	public static void main(String[] args) {
		int x = 10, y = -10;

		int absX = (x >= 0) ? x : -x;
		int absY = (y >= 0) ? y : -y;
		System.out.println("absX: " + absX); // absX : 10
		System.out.println("absY: " + absY); // absY : 10
	}
}
```

*※ 삼항연산자를 활용해서 변수에 값을 저장할 수 있음*

---

# Casting 형변환

> 연산 중간에 데이터의 자료형을 변환하는 것
>
> 객체 형변환과 연관(Swing)

## 종류

- *자동 형변환(묵시적)*
  1. 바이트 크기가 작은 자료형에서 큰 자료형으로 대입하는 경우
     ex) byte → short
  2. 덜 정밀한 자료형에서 더 정밀한 자료형으로 대입하는 경우
     ex) int → float, float는 실수값을 표현하기 때문에 int보다 더 정밀함
  3. 서로 다른 자료형을 가진 데이터들이 연산될 경우
     저장 공간이 더 큰 자료형으로 자동 형변환
  4. 단점 : 메모리 낭비가 심함
- *강제 형변환(명시적) : 변수 앞에 형변환 연산자 작성*
  1. 바이트 크기가 큰 자료형에서 작은 자료형으로 대입하는 경우
  2. 더 정밀한 자료형에서 덜 정밀한 자료형으로 대입하는 경우
  3. 서로 다른 자료형을 가진 데이터들을 연산하는 경우
     바이트 크기가 더 작은 자료형을 가진 변수에 저장하기 위해서는
     강제 형변환으로 자료형을 맞춰 주어야 함
  4. 단점 : 강제로 자료형을 변경하다보니 데이터 손실이 발생할 수 있음
     ex 1) int i = (int)3.5; → 0.5가 탈락되고 3만 저장됨
     ex 2) int iNum = 1000;
     byte bNum = (byte)iNum;
     1000이 byte 저장 용량을 초과해 데이터 손실이 발생하기 때문에
     대입된 값 -24가 저장됨 

*※ boolean은 형변환에서 사용하지 않음*

### 형변환 연산자

> ***(dataType)*** : 괄호 안에 형변환을 원하는 자료형을 작성하면 됨
>
> *ex) (int), (char), (float),,,*

### 사용례_자동 형변환

```java
public class Op5Cast {
	public static void main(String[] args) {
         // 자동 형변환
		// 1. 데이터를 그보다 큰 자료형에 저장
		short s = 12;
		// 2진수로 저장됨 | short에 저장된 12의 경우 00000000 00001100
		int i = s; 
         // 00000000 00000000 00000000 00001100 → 메모리 낭비가 심해짐

		// 2. 서로 다른 자료형이 연산될 경우
		char c = 'A';
		int n = c + 1; 
         /* char(2byte) + int(4byte) → int(4byte) + int(4byte)
          int 저장 공간이 더 크기 때문에 int 자료형으로 저장해야함 */
		System.out.println("n :" + n); // n: 66
        
         int x = 123;
		float y = x + 12.3f; // int + float → float + float → float
		System.out.println("y: " + y); // y: 135.3
        
         byte s2 = 12;
		short s3 = 45;
		int re = s2 + s3; 
		/* 산술연산자 사용시 s2와 s3가 int로 자동 형변환되기 때문에
		변수의 자료형으로 int를 사용해야함 */
		System.out.println("re: " + re); // re: 57
    }
}
```

### 사용례_강제 형변환

```java
public class Op5Cast {
	public static void main(String[] args) {
		char c = 'A';
		int n = c + 1; 
		System.out.println("(char)n:" + (char)n); // (char)n: B
         // 변수 n의 자료형을 강제로 int에서 char로 형변환해서 출력
        
         byte s2 = 12;
		short s3 = 45;
         short re2 = (short) (s2 + s3);
         /* s2, s3가 연산 과정에서 int로 작동하기 때문에 괄호로 묶어
		 연산을 먼저 실행한 뒤에 (short)를 작성해주어야 함, int -> short */
		System.out.println("re2: " + re2); // re2: 57
	}
}
```

### 사용례_System.out.printf() 활용 (1)

> System.out.printf() : 문자열에 양식을 지정해서 출력하는 함수
>
> 형식) printf("출력문자열, 출력양식", 출력대상,,,)
> 출력양식 기호 : %d(정수값), %c(문자), %s(문자열), %f(소수점)
> *※ 출력양식 기호와 출력대상이 1:1로 대응하기 때문에 개수가 같아야 함*

```java
public class Op6Cast2 {
	public static void main(String[] args) {
		int num1 = 20, num2 = 30;

		System.out.printf("첫 번째 숫자=%d, 두 번째 숫자=%d", num1, num2);
         // 첫 번째 숫자=20, 두 번째 숫자=30
        
		System.out.println(); // 줄바꿈
		System.out.print('\n'); // 줄바꿈 특수기호 사용
        
         char ch = 'A';
		System.out.println("ch: "+ch); // ch: A
         // println은 내부에 저장된 ASCII 값을 문자로 변환해서 출력
        
         System.out.printf("문자 %c의 ASCII 값 : %d\n", ch, (int) ch);
         // 문자 A의 ASCII 값 : 65
         /* printf의 %d는 숫자를 그대로 출력하기 때문에
			ch를 int로 형변환 해주어야 함 */
        
		int ch2 = ch;
         // ch에 담겨있던 문자의 ASCII 코드 값이 정수로 ch2에 저장됨
		System.out.println("ch2: "+ch2); // ch2: 65
	}
}
```

### 사용례_System.out.printf() 활용 (2)

```java
public class Op6Cast2 {
	public static void main(String[] args) {
		int java = 90, jsp = 85, oracle = 70;
		int sum = java + jsp + oracle;
		System.out.printf("sum=%d입니다.\n", sum);
		
		int avg = sum/3;
		double avg2 = sum/3;
		System.out.println("avg: "+avg+", avg2: "+avg2); 
         // avg: 81, avg2: 81.0
         /* avg2: sum/3 에서 int로 변환돼서 계산된 뒤에
			double에 저장되기 때문에 81.0으로 출력됨 */
        
         double avg3 = (double)sum/3;
		System.out.println("avg3: "+avg3);
         // avg3: 81.66666666666667
		// sum/3 계산시에 sum을 double로 형변환 해주어야 소수점까지 저장됨
         
         System.out.printf("avg3: %.2f", avg3);
         /* avg3: 81.67, %f로 출력될 소수점 자리수 설정
           형식) "%.소수점자리수f" */
	}
}
```

---

# 제어문

> ***제어문*** : 조건에 따라서 코드의 실행 흐름(순서)을 제어하는 구문
>
> ↔ 순차문 : 코드가 작성된 순서대로 실행되는 문장

# ★조건문

## ☆If문

> 조건식의 진리값이 참인 경우 코드를 실행
>
> 형식) if(조건식) 처리할 문장
> 조건식에는 변수, 수식(관계, 논리연산자) 등이 들어갈 수 있음

### 사용례

```java
public class IfTest {
	public static void main(String[] args) {
		int su = 30;
		if (su % 2 == 0) {
			System.out.println(su+"은(는) 짝수입니다.");
		}
		if (su % 2 == 1) {
			System.out.println(su+"은(는) 홀수입니다.");
		}
        // 30은(는) 짝수입니다.
        /* 30은 2로 나눈 나머지가 0이기 때문에 위의 if문은 실행되고
        	아래의 if문은 실행되지 않음 */
	}
}
```

*※ 코드 블럭 처리 : 실행할 코드가 둘 이상인 경우에 {}중괄호로 코드들을 묶어줌*

## If-Else 문

> 조건식의 진리값이 참인 경우에는 if 다음의 코드를 실행하고
> 진리값이 거짓인 경우에는 else다음의 코드를 실행

### 사용례

```java
public class IfTest {
	public static void main(String[] args) {
		int su = 30;

		if (su % 2 == 1) {
			System.out.println(su+"은(는) 홀수입니다.");
		} else  {
			System.out.println(su+"은(는) 짝수입니다.");
		}
         // 30은(는) 짝수입니다.
         /*
         su를 2로 나눈 나머지가 1인 경우에 if다음의 코드를 실행하고
         나머지가 1이 아닌 경우에 else다음의 코드를 실행하기 때문에
         else다음의 코드가 실행됨
         */
        
         // 삼항연산자, if-else문과 유사함
         String su2 = (su % 2 == 0) ? "짝수" : "홀수";
		System.out.println("입력받은 su의 값은 "+su2+"입니다.");
         // 입력받은 su2의 값은 짝수입니다.
	}
}
```

## 중첩 If문

> if문 내부에 또 다른 if문이 나오는 구문

```java
public class IfTest2 {
	public static void main(String[] args) {
		// 1~100까지의 수를 입력받는다는 조건 하에 홀수, 짝수 판별
		// 1~100 범위에 들지 않는 숫자 → "숫자는 1~100 안에서 입력해 주세요!!"
		int su = 111;
		if ((1 <= su) && (su <= 100)) {
			if (su % 2 == 1) {
				System.out.println(su + "은(는) 홀수입니다.");
			} else {
				System.out.println(su + "은(는) 짝수입니다.");
			}
		} else {
			System.out.println("숫자는 1~100 안에서 입력해 주세요!!");
             // 숫자는 1~100 안에서 입력해 주세요!!
		}
	}
}
```

---

# 선택문

> 다중 if문 대신 사용, 조건문의 일종
>
> if문을 여러 개 사용하면 실행 속도가 느려지기 때문에 사용
>
> switch함수의 매개변수에 들어오는 값에 따라 코드를 실행

## 형식

```java
switch(조건식){
     case 값1:
     실행 코드
     break;
     case 값2:
     실행 코드
     break;
     case 값3:
     실행 코드
     break;
     default: case에 해당하는 값이 없을 때 실행할 코드 
 	 break;        
}
/*
case 값의 개수는 임의로 설정 가능
break : 코드가 실행되다가 break를 만나면,
바로 실행을 중지하고 해당 loop에서 빠져나옴 
*/
```

*※ Java7부터는 swtich~case문의 case 값에 정수 값뿐만 아니라 문자열도 사용 가능*

## 사용례

```java
public class SwitchTest {
	public static void main(String[] args) {
		int su = 33;
        
		switch (su % 2) {
		case 0:
			System.out.println(su + "은(는) 짝수입니다.");
			break;
		case 1:
			System.out.println(su + "은(는) 홀수입니다.");
			break;
		}
         // 33은(는) 홀수입니다.
         /* su%2의 값이 1이기 때문에 case1의 코드가 실행되고
         break로 빠져나감, 가장 마지막 case에는 break 생략 가능 */
	}
}
```



# ★반복문

## while

## do~while

## ☆for문

# 탈출문

---

# 200115 변경사항

float 는 소수점 7자리까지 저장가능

