# 200131

---

# Integer.to~String()

> Integer 클래스 내장 메소드, 인자로 들어온 int형 숫자를 특정 진수의 숫자로 반환

|               *메소드*               |                            *설명*                            |
| :----------------------------------: | :----------------------------------------------------------: |
|   *Integer.toBinaryString(int i)*    | Integer 클래스 정적 메소드, 인자로 들어온 int형 숫자를 2진수 문자열로 반환 |
|    *Integer.toOctalString(int i)*    | Integer 클래스 정적 메소드, 인자로 들어온 int형 숫자를 8진수 문자열로 반환 |
|     *Integer.toHexString(int i)*     | Integer 클래스 정적 메소드, 인자로 들어온 int형 숫자를 16진수 문자열로 반환 |
| *Integer.toString(int i, int radix)* | Integer 클래스 정적 메소드, 인자로 들어온 int형 숫자를 radix(기수) 진수 문자열로 반환<br />Integer.toString(int i)와 함께 Integer 클래스의 일반 메소드 toString()의 오버로딩 메소드 |

*※ 기수(radix, base): 숫자 표현(진법 체계)에 기준이 되는 수*

## 사용례

```java
package j200131;

public class IntStr {

	public static void main(String[] args) {
		int i = 144;
		// Integer.toBinaryString(int i)
		String binary = Integer.toBinaryString(i);	
		
		// Integer.toOctalString(int i)
		String octal = Integer.toOctalString(i);
		
		// Integer.toHexString(int i)
		String hex = Integer.toHexString(i);
		
		// Integet.toString(int i, int radix)
		String binaryRadix = Integer.toString(i, 2);
		String octalRadix = Integer.toString(i, 8);
		String hexRadix = Integer.toString(i, 16);

		System.out.println("2진수: " + binary);	// 2진수: 10010000
		System.out.println("8진수: " + octal);	// 8진수: 220
		System.out.println("16진수: " + hex);		// 16진수: 90
		System.out.println("2진수: " + binaryRadix);	// 2진수: 10010000
		System.out.println("8진수: " + octalRadix);	// 8진수: 220
		System.out.println("16진수: " + hexRadix);	// 16진수: 90
	}

}
```

---

# Final

> final은 '마지막'이라는 뜻으로, 마지막으로 정한 것이니 더 이상 수정할 수 없다는 뜻을 가진 예약어
>
> 변수, 메소드, 클래스에 사용 가능

## final 사용 위치

|   위치   |                             설명                             |
| :------: | :----------------------------------------------------------: |
|  *변수*  | 멤버 변수 및 지역 변수에 모두 사용 가능하며, final 변수는 상수를 의미<br />관례적으로 final 변수의 이름은 모두 대문자로 작성 |
| *메소드* | final 메소드는 하위 클래스에서 재정의 불가, 읽기 전용 메소드가 됨<br /> 메소드의 원래 목적과 상관 없는 기능으로 변경하는 것을 방지하기 위함<br/>	정적 메소드에 많이 사용됨 |
| *클래스* | final 클래스는 상속 불가, 클래스 내부의 어떠한 내용도 수정하지 못하도록 해야 하는 경우에 사용 |

## 사용례_final 변수

```java
package j200131;

class Parent {

	// final + 멤버 변수 or 지역 변수 => 상수화 되어 값이 고정됨
	final int COUNT = 1;

	public static void main(String[] args) {
		// Parent 클래스 객체 생성
		Parent p = new Parent();
        
         // 상수 변경 시도 => 에러 발생
//		p.COUNT = 5;
//		The final field Parent.count cannot be assigned, 상수는 값을 새롭게 받을 수 없음
        
		System.out.println("p.count: " + p.COUNT);	// p.COUNT: 1
	}

}

```

## 사용례_final 메소드

```java
package j200131;

class Parent {

	// final + 메소드 => 상속은 허용하지만 메소드 오버라이딩(재정의) 금지
	final void sub() {
		System.out.println("메소드 재정의 제한");
	}
}

public class FinalTest extends Parent {
	// final 메소드 오버라이딩 시도 => 에러 발생
	/*	Cannot override the final method from Parent
	void sub() {
		System.out.println("final 메소드는 오버라이딩 불가");
	}
	*/
    
	public static void main(String[] args) {
		
	}

}
```

## 사용례_final 클래스

```java
package j200131;

// final + 클래스 => 상속 금지 클래스
final class Parent {

}

//	Parent 클래스 상속 시도 => 에러 발생
//	The type FinalTest cannot subclass the final class Parent
//	public class FinalTest extends Parent { 

	public static void main(String[] args) {

	}

}
```

---

# Static

> 이전에 다룬 적이 있기 때문에 예제만 올림

```java
package j200131;

// Static 활용 예제

class Car {
	String color;
	String model;
	String owner;
	// 차의 모델과 상관없이 판매량의 합계만 저장하고자 하는 변수
	// Static 변수: 모든 인스턴스에서 공유하고자 하는 변수
	static int serialNumber;

	// 생성자, [Source] 탭 -> [Generate Constructor using Fields...] 탭에서 생성자 자동 생성 가능
	public Car(String color, String model, String owner) {
		this.color = color;
		this.model = model;
		this.owner = owner;
		serialNumber++; // 모델에 상관없이 공통으로 serialNumber의 값이 1씩 올라감
	}

	// setter, getter
	// [Source] 탭 -> [Generate Getters and Setters...] 탭에서 setter, getter 자동 생성 가능

	// 차 생산량을 반환하는 static getter
	public static int getNumber() {
		return serialNumber;
	}

	// =================== java 변수 정리 =====================
	// 멤버 변수(=인스턴스 변수) : 클래스 내부에 선언된 각 개체별로 소유하는 변수,
	// 일반 메소드에서만 불러다 사용할 수 있음
	// 정적 변수(=클래스 변수): 모든 객체가 공유할 수 있는 변수, 프로그램이 작동하는 동안 메모리에 상주
	// 일반 메소드와 정적 메소두 모두에서 불러다 사용 가능
	// 지역 변수: 메소드 매개변수 및 메소드 내부에 선언된 변수, 스택에 저장

}

public class CarFactory {

	public static void main(String[] args) {
		// Car 클래스 객체 생성
		Car c1 = new Car("Red", "SM5", "test-1");
		System.out.println("지금까지의 차 생산량: " + Car.serialNumber);

		Car c2 = new Car("Blue", "Sonata", "test-2");
		System.out.println("지금까지의 차 생산량: " + Car.serialNumber);

		Car c3 = new Car("Orange", "Martiz", "test-3");
		System.out.println("지금까지의 차 생산량: " + Car.serialNumber);

		System.out.println("정적 getter로 불러온 차 생산량: " + Car.getNumber());
		System.out.println(c1.getNumber());
	}

}
```

---

# Abstract 추상 클래스 & 추상 메소드

## Abstract

> 해당 클래스 /메소드가 추상 클래스/추상 메소드임을 명시하는 예약어

- 클래스나 메소드 앞에 **abstract**를 붙여서 추상 클래스 or 추상 메소드임을 명시
- 클래스에 추상 메소드가 포함되어 있는 경우 반드시 클래스에 abstract를 작성해야 함
- abstract는 접근 제어자 앞이나 뒤에 사용할 수 있음

### 작성법

```java
// ① abstract를 접근 제어자 앞에 작성
abstract 접근 제어자 class 클래스명 {
    abstract 접근 제어자 반환형 메소드명();
}

// ② abstract를 접근 제어자 뒤에 작성
접근 제어자 abstract class 클래스명 {
    접근 제어자 abstract 반환형 메소드명();
}
```

## 추상 클래스

> 추상 메소드를 하나라도 가지고 있는 클래스를 추상 클래스라고 함
> 즉, 일반 클래스에는 추상 메소드가 있을 수 없음

- 추상 클래스를 상속받은 자식 클래스는 반드시 추상 메소드를 오버라이딩해야 함
  추상 클래스가 자식 클래스에 추상 메소드의 재정의를 **강요**함
  ↔ final class: 오버라이딩을 제한하기 위해서 전적으로 상속을 금지함
- 추상 클래스는 **프로그램의 설계**를 목적으로 함
  ↔ 일반 클래스는 여러 개의 객체를 생성하고 데이터를 저장하는 것을 목적으로 함
- 추상 클래스는 객체로 생성할 수 없음
  자식 클래스에서 추상 클래스를 상속받고 추상 메소드를 오버라이딩해서 구현을 마친 뒤,
  자식 클래스를 이용해서 객체를 생성해야 함

### 추상 클래스 장점

- 추상 클래스에서 설계가 완료되면 자식 클래스에서 상속을 받아서 기능을 확장하는데 용이
- 자식 클래스에 추상 메소드의 구현을 강요하기 때문에 표준화 정도를 높임
- 클래스들의 공통 사항을 한 곳에서 관리할 수 있기 때문에 개발 및 유지보수가 편리해짐

## 추상 메소드

> 메소드는 **()**선언부와 **{}**구현부로 나누어지는데
> **선언부까지만 작성**하고 구현부는 작성하지 않은 메소드

- 메소드 내용이 상속받는 클래스에 따라 달라지기 때문에 추상 메소드 사용
- 구현부는 해당 클래스를 상속받는 하위 클래스에서 반드시 작성해야 함
  {}구현부를 작성하지 않은 경우 에러 발생
- 주석으로 어떤 기능을 수행하는 메소드인지 설명해야 함
- 오버라이딩 메소드에는 abstract를 작성하지 않음

## 사용례

```java
package j200131;

// 추상 메소드를 가진 추상 클래스
abstract class Exam {

	// 일반 메소드
	public int sum(int x, int y) {
		return x + y;
	}

	/* 추상 메소드, 자식 클래스에서 오버라이딩을 완료해야 함 */
	// 하위 클래스에서 "안녕?"을 출력하는 메소드로 구현
	abstract public void sayHi();

	// 하위 클래스에서 매개변수 a와 b를 더한 뒤 결과를 출력하는 메소드로 구현
	abstract public void printSum(int a, int b);
}

public class AbstractTest extends Exam {

	// Exam 클래스의 sayHi() 추상 메소드 오버라이딩
	public void sayHi() {
		System.out.println("안녕?");
	}

	// Exam 클래스의 printSum() 추상 메소드 오버라이딩
	public void printSum(int a, int b) {
		int result = sum(a, b);
		System.out.println(a + "과(와) " + b + "의 합은 " + result + "(이)야");
	}

	public static void main(String[] args) {

		// 하위 클래스인 AbstractTest 객체 생성
		AbstractTest at = new AbstractTest();

		// AbstractTest 클래스에서 재정의된 메소드 호출
		at.sayHi();				// 안녕?
		at.printSum(30, 40);	 // 30과(와) 40의 합은 70(이)야

	}

}
```

---

# 메소드 호출 방식 Call by Value & Call by Reference

> 메소드를 호출할 때 매개변수에 전달되는 인자의 자료형에 따라 메소드 호출 방식이 구분됨
>
> Call by Value와 Call by Reference 두 개의 메소드 호출 방식(인자 전달 방식)이 존재

## Call by Value

> 값에 의한 전달 방법, 매개변수의 자료형으로 기본 자료형 8가지 사용
>
> **기존의 값을 복사해서 전달**하기 때문에 원본에는 변함이 없음

### 사용례

```java
package j200131;


public class CallByValue {
	// int형 변수 r, g, b를 전달받아서 값을 변경하고 출력하는 메소드
	static void changeColor(int r, int g, int b) {
		r += 10;
		g += 50;
		b += 10;
		System.out.println("changeColor_red: " + r + ", green: " + g + ", blue: " + b);
	}

	public static void main(String[] args) {

		// rgb(0~255) 각각의 변수 r, g, b 초기화
		int r = -1, g = -1, b = -1;
		System.out.println("before_red: " + r + ", green: " + g + ", blue: " + b);
         // before_red: -1, green: -1, blue: -1

		/* r, g, b 를 인자로 받아서 changeColor() 메소드를 호출한 뒤
		  메소드의 지역 변수 r, g, b 각각의 값 출력
		  ※ 인자가 전달될 때는 원래의 값을 복사해서 전달함 */
		changeColor(r, g, b);
         // changeColor_red: 9, green: 49, blue: 9

		// changeColor()의 r, g, b에 main()의 r, g, b의 값 즉, value가 복사돼서
         // 전달되었기 때문에 main()의 r, g, b에는 변함이 없음
		System.out.println("after_red: " + r + ", green: " + g + ", blue: " + b);
         // after_red: -1, green: -1, blue: -1
	}

}
```

*※ main()의 r, g, b가 저장된 메모리 주소와* 
*changeColor()의 r, g, b가 저장된 메모리 주소가 다르기 때문에*
*main() r, g, b의 주소가 아니라 값만 복사되어 changeColor() r, g, b로 전달됨*
*따라서 main() r, g, b의 값은 변화하지 않음*

## Call by Reference

> 주소에 의한 전달 방법, 매개변수의 자료형은 참조형(=클래스형, 객체형)
>
> **주소값 즉, 원본을 전달**하기 때문에 원본의 값이 수정됨

### 사용례

```java
package j200131;

class RGBColor {
	// 멤버 변수
	int r, g, b; // 0, 0, 0

	// 생성자
	RGBColor(int r, int g, int b) {
		this.r = r;
		this.g = g;
		this.b = b;
	}
}

public class CallByRef {

	// 색상을 변경하고 변경된 값을 출력하는 정적 메소드
	static void changeColor(RGBColor rgbc) {
		System.out.println("rgbc 주소: " + rgbc);
		rgbc.r += 10;
		rgbc.g += 50;
		rgbc.b += 10;
		System.out.println(
            "changeColor_red: " + rgbc.r + 
            ", green: " + rgbc.g + ", blue: " + rgbc.b);
	}

	public static void main(String[] args) {

		// RGBColor 클래스 객체 생성, 초기화
		RGBColor rgb = new RGBColor(-1, -1, -1);

		// rgb 객체의 주소 출력
		System.out.println("rgb 주소: " + rgb);
         // rgb 주소: j200131.RGBColor@15db9742

		// 변경 전 rgb 객체의 멤버변수 r, g, b 출력
		System.out.println("before_red: " + rgb.r + 
                           ", green: " + rgb.g + ", blue: " + rgb.b);
         // before_red: -1, green: -1, blue: -1

		// changeColor() 메소드에 rgb 객체(주소)를 인자로 전달하면서 호출
		changeColor(rgb);
         // rgbc 주소: j200131.RGBColor@15db9742
         // changeColor_red: 9, green: 49, blue: 9

		// 변경 후 rgb 객체의 멤버변수 r, g, b 출력
		System.out.println("after_red: " + rgb.r + 
                           ", green: " + rgb.g + ", blue: " + rgb.b);
         // after_red: 9, green: 49, blue: 9
	}

}
```

*※ changeColor()의 인자로 main()의 rgb 객체가 저장된 메모리 주소가 전달되었기 때문에*
*changeColor()의 매개변수 rgbc의 주소가 main()의 rgb 객체의 주소와 같아짐*
*따라서 같은 주소에 저장된 r, g, b를 수정한 것이기 때문에 r, g, b의 값이 변경됨*

---

객체 생성 및 전달 방법

1. new 연산자 이용
2. 메소드 매개변수 이용
3. 메소드 반환형 이용