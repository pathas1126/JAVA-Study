# 200205

---

# Object Type Casting 객체 형 변환

>객체간 자료형을 변환하는 것

- 인터페이스, 배열, 클래스에 적용
- 상속 관계 때문에 만들어진 기능

## Upcasting 묵시적 객체 형 변환

> 하위 클래스에서 상위 클래스로 자료형을 변환하는 것

- 하위 클래스는 이미 상위 클래스를 상속받아서
  상위 클래스의 모든 변수와 기능을 가지고 있기 때문에
  하위 클래스의 객체를 상위 클래스의 자료형으로 변환해서 생성할 수 있음
- 하위 클래스의 객체를 상위 클래스의 자료형으로 선언하기만 하면 됨
- 상위 클래스형 변수(ex. 배열)에 대입되는 경우에도 묵시적 형 변환이 일어남
- 상위 클래스형으로 생성된 객체는 상위 클래스의 멤버 변수와 메소드만 사용 가능
  **단,** 메소드가 하위 클래스에서 오버라이딩되었다면 오버라이딩된 메소드 호출
- 상위 클래스에서는 하위 클래스로 묵시적 형 변환을 할 수 없음

### 형식

```java
상위클래스형 하위클래스 객체명 = new 하위클래스형();

// SuperClass sub = new SubClass();
```

*※ 클래스형과 클래스의 자료형, 인스턴스형과 인스턴스 자료형은 모두 비슷한 의미로 사용*

### 예제

```java
package j200205;

// Shape_상위 클래스
class Shape {

	// 모든 도형에서 사용하는 메소드
	void draw() {
		System.out.println("Shape");
	}

	// Shape 전용 메소드
	void shapeDraw() {
		System.out.println("Shape");
	}
}

// Point_하위 클래스
class Point extends Shape {
	// 오버라이딩
	void draw() {
		System.out.println("Point");
	}

	// Point 클래스 메소드
	void pointDraw() {
		System.out.println("Point");
	}
}

public class ShapeTest {

	public static void main(String[] args) {

		// 클래스형에 맞는 객체 생성
		Shape s = new Shape();
		Point p = new Point();
        
         // 묵시적 형변환_객체 생성
         Shape sp = new Point();

		// 각자 메소드 출력
		s.shapeDraw();	// Shape
		p.pointDraw();	// Point
         sp.shapeDraw(); // Shape
        
         sp.draw();	 	// Point, 오버라이딩된 메소드가 호출됨
       	 // sp.pointDraw() 메소드는 호출 불가
        
		// 묵시적 형변환_배열 요소에 대입
		// 배열에는 같은 자료형만 저장될 수 있는데
		// 하위 클래스 객체는 상위 클래스 배열에 묵시적으로 들어갈 수 있음
        
         // Shape 자료형 배열 생성 및 초기화
		Shape[] sh = new Shape[3];
		sh[0] = s; // Shape 
		sh[1] = p; // Point
         sh[2] = sp; // Shape

		// 배열에 객체들이 잘 저장됐는지 확인
		for (int i = 0; i < sh.length; i++) {
			sh[i].draw();
		}
        
         /*
         Shape
         Point
         Point
         */
	}

}
```

## Instanceof

> 왼쪽에 있는 객체가 오른쪽 클래스의 인스턴스인지 확인하는 예약어
> 맞다면 true, 아니라면 false 반환

### 형식

```java
객체명 instanceof 클래스명
```

### 예제

```java
package j200205;

class Shape {

	void draw() {
		System.out.println("Shape");
	}

	void shapeDraw() {
		System.out.println("Shape");
	}
}

class Point extends Shape {

	void draw() {
		System.out.println("Point");
	}

	void pointDraw() {
		System.out.println("Point");
	}
}


public class ShapeTest {
    
    // Shape 객체 클래스형 확인 메소드
    static void whoAreYou(Shape sh) {
        
		// 객체가 Shape형인지 확인
		if(sh instanceof Shape)
			System.out.println("I am Shape");
		else
			System.out.println("I am not Shape");
        
		// Point형인지 확인
		if(sh instanceof Point)
			System.out.println("I am Point");
		else
			System.out.println("I am not Point");
	}

	public static void main(String[] args) {

		// 객체 생성
		Shape s = new Shape();
		Point p = new Point();
		Shape sp = new Point();

		Shape[] sh = new Shape[3];
		sh[0] = s; // Shape
		sh[1] = p; // Shape + Point
		sh[2] = sp;

		// 객체 자료형 확인
		for (int i = 0; i < sh.length; i++) {
			sh[i].draw();
			whoAreYou(sh[i]);
		}
         /*
         Shape
         I am Shape
         I am not Point
         Point
         I am Shape
         I am Point
         Point
         I am Shape
         I am Point
         */
	}

}
```

*※ Shape 클래스로 생성된 객체는 Point 클래스의 객체가 아니지만,*
*Point 클래스로 생성된 객체는 Point 클래스의 객체이면서 동시에 Shape 클래스 객체임*
*자동 형 변환으로 생성된 객체 역시 Point 클래스 객체이면서 Shape 클래스 객체임*

## Downcasting 명시적 객체 형 변환

> 상위 클래스로 생성된 객체를 하위 클래스로 강제로 형 변환하는 것
> 상위 클래스로 형 변환되었던 하위 클래스를 다시 하위 클래스형으로 형 변환

- 상위 클래스에서 하위 클래스로 형변환을 할 때는 하위 클래스 자료형을 명시해야 함
- instanceof 예약어로 상속 관계를 확인하고 형 변환을 해야 실행 오류를 방지할 수 있음
- 명시적 형 변환시 상속 관계가 아니더라도 클래스 자료형만 맞으면
  컴파일 에러는 발생하지 않지만, 프로그램을 실행하면 실행 에러 발생

### 형식

```java
하위클래스형 하위클래스 객체명 = (하위클래스형) 상위클래스 객체명;
// SubClass sub = (SubClass) superClass; 
```

### 예제

```java
package j200205;

class Shape {

	void draw() {
		System.out.println("Shape");
	}

	void shapeDraw() {
		System.out.println("Shape");
	}
}

class Point extends Shape {
    
	void draw() {
		System.out.println("Point");
	}

	void pointDraw() {
		System.out.println("Point");
	}
}

public class ShapeTest {

	public static void main(String[] args) {

		// 묵시적 형 변환으로 Shape 형 객체 생성
		Shape sp = new Point();

		if (sp instanceof Point) {
            // sp 객체가 원래 Point 클래스로 생성된 것인지 확인
			System.out.println("Point 클래스 객체!");
            
             // 명시적 형 변환
			Point pp = (Point) sp;
			pp.pointDraw();
             // Point형 객체가 되었기 때문에 pointDraw() 메소드에 접근 가능
		}
         /*
         Point 클래스 객체!
         Point
         */
	}
}
```

---

# Exception 예외

> 자바 프로그램의 정상적인 실행을 방해하는 이벤트
>
> 자바에서 예외는 예외 이벤트와 그에 대한 정보를 담고 있는 객체임

## 예제

```java
package j200205;

public class ExceptionTest {

	public static void main(String[] args) {
		String greetings[] = { "객체형변환", "예외처리", "예외처리방법" };
		int i = 0;
		while(i<4) {
			System.out.println(greetings[i]);
			i++;
		}
         /*
         객체 형 변환
         예외 처리
         예외 처리 방법
         Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 3
         at j200205.ExceptionTest.main(ExceptionTest.java:9)
         */
	}

}
```

*※ java.lang.ArrayIndexOutOfBoundsException: 3*
*greetings 배열에 index 3에 해당하는 요소가 없기 때문에 예외가 발생했다는 메세지*

*※ at j200205.ExceptionTest.main(ExceptionTest.java:9)*
*ExceptionTest.java의 9번째 줄에 문제가 있다는 메세지*

## 종류

- **RuntimeException**: 논리적인 예외, 문법적으로는 문제가 없지만 프로그램이 실행되지 않는 경우
- non-RuntimeException: 물리적인 예외, 문법에 맞지 않아서 발생하는 예외
  RuntimeException에 해당하지 않는 예외들이 포함됨
  ex) 오타 → 수정 → 컴파일

## RuntimeException

> Execption 클래스의 하위 클래스인 RuntimeException 클래스

### 자주 발생하는 예외

| 런타임 예외                 | 설명                                                         |
| --------------------------- | ------------------------------------------------------------ |
| *NullPointerException*      | 객체를 생성하지 않고 메소드를 호출하는 경우                  |
| *ArithmeticException*       | 5/0 과 같이 수학적 계산에서 예외가 발생한 경우               |
| *ClassCastException*        | 객체 형 변환에서 예외가 발생한 경우                          |
| *IndexOutOfBoundsException* | 배열 첨자에서 예외가 발생한 경우                             |
| *NumberFormatException*     | 숫자형 인자를 요구하는 매개변수에 숫자형이 아닌 인자가 주어진 경우 발생하는 예외<br />ex) "5" -> 5, "a" -> X |

## IOException

> Execption 클래스의 하위 클래스인 IOException 클래스
> non-RuntimeException 중에서 가장 많이 발생하는 예외 클래스

# Exception 예외 처리

> 예외가 발생했을 때 자바 프로그램이 정상적으로 실행되도록 예외를 처리하는 것

## try ~ catch ~ finally

> 예외가 발생했을 때 예외를 어떻게 처리할 것인가를 결정하는 구문

### 형식

```java
try {
    // 예외 발생 가능성이 있는 코드
} catch([예외 처리 클래스명] [예외 처리 객체명]) {
    // 예외 처리, 보통 예외 메세지 출력
} finally {
    // 예외 발생과 상관없이 반드시 처리해야하는 코드
    // ex) DB 연동 해제, 메모리 해제 구문
}
```

*※ **catch문**은 여러 개 작성 가능*

### |  파이프 기호

> catch()문에서 2개의 에러를 처리할 때 사용하는 기호

#### 형식

```java
catch([예외 처리 클래스명] | [예외 처리 클래스명] [예외 처리 객체명])
    
// catch(ArithmeticException | NumberFormatException e) 
```

### Exception Class

> 각각의 예외 클래스들을 포함하는 상위 클래스

- 예외가 하나인 경우에 Exception 클래스명만으로도 작성 가능
- Exception 클래스가 상위 클래스이기 때문에 그 외의 예외들은 자동 형 변환되어 인자로 전달 가능
- **복수의 catch문이 있는 경우 가장 마지막에 작성해야 함**

### Throwable Class Method

> Catch 구문에서 자주 사용되는 Throwable 클래스 메소드
> 주로 예외에 대한 정보 메세지 출력

| 메소드              | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| *getMessage()*      | Throwable 클래스 일반 메소드, 객체명.getMessage()로 사용<br />가장 간단한 에러 메세지, 발생한 예외 내용만 출력 |
| *toString()*        | Throwable 클래스 일반 메소드, 객체명.toString()으로 사용<br />권장되는 방법, 발생한 예외 종류 출력<br />toString()을 생략하고 객체명으로만 출력해도 동일한 결과가 나옴 |
| *printStackTrace()* | Throwable 클래스 일반 메소드, 객체명.printStackTrace()로 사용<br />발생한 예외의 종류와 문제가 있는 코드의 라인 출력<br />출력 코드 없이 단독으로 사용 |

### 예제

```java
package j200205;

public class ExceptionTotal {

    // 매개변수를 Run Configurations에서 설정
	public static void main(String[] args) {
		try {	// 에러 발생 가능성이 있는 코드 작성
			int a = Integer.parseInt(args[0]);
			int b = Integer.parseInt(args[1]);
			System.out.println("a: " + a + ", b:" + b);
			System.out.println("a를 b로 나눈 몫: " + (a / b));
            
      	 // 수식 예외 처리
		} catch (ArithmeticException e) {
			System.out.println(e.getMessage());
         // a = 9, b = 0
         // / by zero
            
         // 배열 첨자 예외 처리
		} catch (IndexOutOfBoundsException e) {
			System.out.println(e);
         // a = 9
         // java.lang.ArrayIndexOutOfBoundsException: 1
            
         // 숫자 변환 실패 예외 처리   
		} catch (NumberFormatException e) {
			System.out.println(e.toString());
         // a = 9, b = c
         // java.lang.NumberFormatException: For input string: "c"
            
         // 모든 종류의 예외 처리 가능
		} catch (Exception e) {	
			e.printStackTrace();
         // a = 9, b = c
         /*
         바로 위의 catch문이 없는 경우
         java.lang.NumberFormatException: For input string: "c"
         at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
         at java.lang.Integer.parseInt(Integer.java:580)
         at java.lang.Integer.parseInt(Integer.java:615)
         at j200205.ExceptionTotal.main(ExceptionTotal.java:9)
         */ 
            
         // 예외 발생과 상관 없이 반드시 실행
		} finally { 
			System.out.println("에러 발생과 상관 없이 반드시 실행");
		}
	}

}

```

## throws

> 예외를 해당 메소드에서 처리하지 않고 미룬 후
> 메소드를 호출하여 사용하는 부분에서 예외를 처리하는 방법

### 형식

```java
접근제어자 반환형 메소드명() throws 예외 처리 클래스명 {}
```

*※ 복수의 예외 처리 클래스명 작성 가능*

## throw 사용자 정의 예외

> 사용자 정의 예외로 예외를 임의로 발생시켜서 프로그램을 테스트 할 수 있음

- 이미 존재하는 예외의 경우 throw를 사용하여 바로 예외를 발생시킬 수 있음
- 사용자 정의 예외의 경우 발생시키고자 하는 예외와 가장 유사한 예외 클래스를 상속
  잘 모르겠다면 가장 상위 클래스인 Exception 클래스 상속

### 형식_사용자 정의 예외 클래스

```java
class 사용자 정의 예외 클래스명 extends 예외 클래스명{
    // 생성자
    사용자 정의 예외 클래스명(String msg){
        super(msg);
    }
}
```

*※ String msg: 에러 메세지를 인자로 받는 매개변수*
*상위 예외 클래스 생성자를 호출하고 예외 메세지를 인자로 전달받아서 예외 객체 생성*

### 형식_예외 발생

```java
throw new 예외 처리 클래스명("예외 메세지");
```

## 예제_throws & throw

```java
package j200205;

import java.util.Scanner;

// 사용자 정의 예외, Exception 클래스 상속
class OverLength extends Exception {
	// 생성자, 예외 메세지를 인자로 전달받아서 예외 객체 생성
	OverLength(String message) {
		super(message);
	}
}

public class PrintString {

	// Overlength 예외를 메소드 호출시 처리하도록 미룸
	static void print() throws OverLength {
		// 스캐너 객체 생성
		Scanner sc = new Scanner(System.in);

		// 문자열 입력
		System.out.println("문자열을 입력해주세요.");
		String str = sc.nextLine();

		// 문자열의 길이가 5자 이상일 때 예외 발생
		if (str.length() >= 5)
			throw new OverLength("문자열은 5자 이상 입력할 수 없습니다.");
	}

	public static void main(String[] args) {
		// 예외 처리
		try {
			PrintString et = new PrintString();
			print();
			// 예외 발생시 예외 정보 출력
		} catch (Exception e) {
			System.out.println(e);
		}
		/*
		문자열을 입력해주세요.
		안녕하세요??
		j200205.OverLength: 문자열은 5자 이상 입력할 수 없습니다.
		*/
	}

}
```

---

# 예습

1. 입출력
2. 컬렉션
3. 제너릭?