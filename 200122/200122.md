# 200122

## 메소드 작성 이유

1. 높은 재사용성 → 언제든지 불러다 사용 가능
2. 중복된 코드 제거 → 코드 감량
3. 프로그램 구조화 → 체계적으로 실행

---

# Constructor 생성자

> 객체 생성시 멤버 변수의 초기화 및 객체 복사의 역할을 담당함

## polymorphism 다형성

> 객체가 다양한 형태로 표현될 수 있다는 개념으로,
> 같은 메서드를 호출해도 다양한 결과를 도출할 수 있음
>
> '틀'을 가진 객체를 구체적인 객체로 표현 가능하다는 뜻
>
> 생성자와 연관이 있음

## 개요

1. *객체가 생성될 때,* 가장 처음 ***자동으로 호출***되는 특수한 메소드
2. 생성자명은 클래스명과 동일하게 작성
   ↔ TypeScript : constructor
3. 메서드에 return형(반환값 자료형)을 명시하지 않음
   *void도 작성하지 않음*

## 생성자 / Set() Method 비교

### 공통점

- 멤버 변수에 데이터를 저장

### 차이점

- 생성자 : 멤버 변수 초기화시, 여러 개의 값을 한꺼번에 저장하는 경우 사용
  ex) 회원가입
- set() 메소드 : 저장되어 있는 값을 중간에 수정하는 경우에 사용
  ex) 회원정보 수정 : 주소, 이메일만 수정


## Constructor 생성자

> 매개변수나 구현 코드가 존재하는 생성자
>
> 프로그래머가 임의로 작성하며, 객체 생성시 초기화할 멤버 변수를 설정함

### Default Constructor 기본 생성자

> 매개변수와 구현 코드가 존재하지 않는 생성자
>
> 생성자를 작성하지 않은 클래스는 클래스 파일을 컴파일할 때
> 자바 컴파일러가 자동으로 생성자를 만들어 줌

### 형식

```java
// 생성자 작성 형식, 생성자명은 클래스명과 동일하게 지정해야 함
생성자(매개변수,,,,){ Java Code; }
    
// 기본 생성자 작성 형식, 자동으로 생성되지만 클래스 안에 작성할 수도 있음
생성자(){}

// 생성자 호출 형식, 'new 생성자()'가 기본 생성자임
클래스명 객체명 = new 생성자();
```

### 사용례

```java
class Person {

	// 멤버 변수
	private String name; // 이름
	private int age; // 나이
	
	// 생성자
	Person(){
		name="홍길동";
		age=23;
	}

	// set() 메소드
	public void setName(String n) {
		name = n;
	}
	public void setAge(int a) {
		if (a > 0) {
			age = a;
		} else {
			System.out.println("나이의 값은 음수일 수 없습니다!");
			age = 23; 	//	기본값 설정
		}
	}
    
	// get() 메소드
	public String getName() {return name;}
	public int getAge() {return age;}
	
	// 정보 출력 메소드
	void display() {
		System.out.println("이름: " + name + ", 나이: " + age);
	}
}

public class PersonHandling {

	public static void main(String[] args) {

		Person p = new Person();	
         // Person 클래스의 객체 p를 생성하면서 생성자 Person 호출
		p.display();	// 이름: 홍길동, 나이: 23
		
		p.setAge(33);
		p.setName("히히히");
		p.display();	// 이름: 히히히, 나이: 33
	}
}
```

---

# Overloading 오버로딩

> 메소드의 이름은 동일하게 지정하고 매개변수의 유형과 개수를 변경하여
> 여러 개의 메소드를 하나의 메소드처럼 정의하는 기법
>
> → 비슷한 유형의 메소드들이 여러 개 필요할 때
> 서로 다른 메소드들을 마치 하나의 메소드처럼 사용할 수 있음

1. **메소드 이름 동일하게 설정**
2. 메소드 **매개변수 유형, 개수 다르게 설정**
3. 필요에 따라 메소드 return형을 다르게 설정
   *※ return형만 다르게 작성하면 에러 발생*

### 사용례_메소드 오버로딩

```java
public class PrintTest {
	
	// Method Overloading, 매개변수 O, 반환값 X
	void print(char c) {	// char형 매개변수
		System.out.println("입력받은 문자: "+c);
	}
	
	void print(int i) {		// int형 매개변수
		System.out.println("입력받은 정수: "+i);
	}
	
	void print(boolean b) {	 // boolean형 매개변수
		System.out.println("입력받은 논리값: "+b);
	}
	
	public static void main(String[] args) {
		PrintTest pt = new PrintTest();
		pt.print('A');		// 입력받은 문자: A
		pt.print(23);		// 입력받은 정수: 23
		pt.print(23>33);	// 입력받은 논리값: false
        
	}
```

*※ 메소드 이름은 print로 동일하지만 매개변수 유형에 따라서 서로 다른 메소드가 호출됨*

## Constructor Overload 생성자 오버로드

> 다양한 방법으로 멤버변수의 값을 초기화할 수 있도록 함
>
> 생성자도 하나의 메소드이기 때문에 메소드 오버로딩과 형식은 동일함

### 사용례_생성자 오버로드

```java
class Person {

	// 멤버 변수
	private String name; // 이름
	private int age; // 나이
	
	// 기본 생성자, 생략 가능
	Person(){}
	
	// 생성자 오버로드, 가능한 조합 개수=2의 멤버변수 개수 제곱(기본생성자 포함)
	Person(int a){
		age = a;
	}
    
    Person(String n){
		name = n;
	}
	
    // 여러 가지 조합이 가능하지만 보통 아래의 형식을 많이 사용함
	Person(String n, int a){
		name = n;
		age = a;
	}
    
    // 정보 출력 메소드
	void display() {
		System.out.println("이름: " + name + ", 나이: " + age);
	}
    
public class PersonHandling {
	public static void main(String[] args) {

		Person p = new Person();
         // Person 클래스의 객체 p를 생성하면서 기본생성자 Person 호출
		p.display();	// 이름: null, 나이: 0
		
		Person p2 = new Person(23);
		p2.display();	// 이름: null, 나이: 23
		
		Person p3 = new Person("홍길동");
		p3.display();	// 이름: 홍길동, 나이: 0
		
		Person p4 = new Person("강감찬", 23);
		p4.display();	// 이름: 강감찬, 나이: 23
	}
}
```

*※ 생성자의 이름은 모두 Person으로 동일하지만
매개변수에 따라 서로 다른 생성자가 호출되고, 멤버 변수에 저장되는 값이 달라짐*

*※ 멤버 변수의 값을 따로 설정하지 않으면 **문자 자료형은 null**,*
***정수, 실수 자료형은 0,***
***논리형은 false****로 기본값이 초기화됨*

### 사용례_생성자 오버로드 + 메소드 오버로딩

#### Method간 호출

1. main() → 일반 메소드*[객체 생성, 객체명.메소드명(~)]*
2. 서로 다른 클래스 : 일반 메소드 → 일반 메소드*[객체생성, 객체명.메소드명(~)]*
3. 동일한 클래스 : 생성자, 일반 메소드 → 일반 메소드*[메소드명(~)]*
   *※ 동일한 클래스 내의 메소드는 메소드 이름만으로 호출 가능*

```java
public class PrintTest {
	
	/* Constructor Overload + Method Overloading
    	생성자 내부에서 클래스 내의 다른 메소드 호출 */
	PrintTest(){};
	PrintTest(char x){
		print(x);
	};
	PrintTest(int y){
		print(y);
	};
	PrintTest(boolean z){
		print(z);
	};
	
	// Method Overloading, 매개변수 O, 반환값 X
	void print(char c) {
		System.out.println("입력받은 문자: " + c);
	}
	
	void print(int i) {
		System.out.println("입력받은 정수: " + i);
	}
	
	void print(boolean b) {
		System.out.println("입력받은 논리값: " + b);
	}
	
	public static void main(String[] args) {
		PrintTest pt1 = new PrintTest('v');		// 입력받은 문자: v
		PrintTest pt2 = new PrintTest(23);		// 입력받은 정수: 23
		PrintTest pt3 = new PrintTest(23 > 11);	// 입력받은 논리값: true
	}
}
```

---

# This

> 생성된 인스턴스(객체) 스스로를 가리키는 예약어
>
> 멤버 변수와 메서드 매개변수의 이름이 같을 경우에 컴퓨터가 구분하지 못하는 경우 발생
> → 멤버 변수 이름 앞에 this 작성

## ① 자신의 인스턴스를 가리키는 This

> main()에서 같은 클래스를 이용해서 서로 다른 이름의 객체를 생성 하더라도
> 각각의 객체 내의 메소드와 멤버 변수를 스스로의 객체에서 찾을 수 있도록 this를 사용

### 참조 변수

> 인스턴스를 가리키는 변수, '클래스 이름@메모리 주소'가 출력됨

```java
public class ThisTest2 {

	// 기본 생성자
	ThisTest2(){
		// 자기 객체의 참조 변수를 출력할 수 있도록 this 사용
		System.out.println("현재 생성된 객체: " + this);
	}
	public static void main(String[] args) {
		
		ThisTest2 tt = new ThisTest2();
		System.out.println("main()에서 생성된 tt객체: " + tt);
         /* 현재 생성된 객체: j200122.ThisTest2@15db9742
         	main()에서 생성된 tt객체: j200122.ThisTest2@15db9742 */
		
		ThisTest2 tt2 = new ThisTest2();
		System.out.println("main()에서 생성된 tt2객체: " + tt2);
         /* 현재 생성된 객체: j200122.ThisTest2@6d06d69c
         	main()에서 생성된 tt2객체: j200122.ThisTest2@6d06d69c */
	}
}
```

*※ 기본 생성자 내부에 작성된 this가 생성된 객체에 따라 다른 참조 변수를 가리킴*

### 사용례

```java
public class ThisTest {

	private int a = 100;

	public void setA(int a) {
		this.a = a; 	/* a = a; 로 작성하면 setA()로 값을 저장하지 못하고
        					100이 출력됨 */
	}
	
	public int getA() {
		return a;
	}
	
	public static void main(String[] args) {
         // 객체 생성
		ThisTest tt = new ThisTest();
         /* this.a = a; 에서 this는 tt 인스턴스(객체)를 가리키며,
        	여러 개의 객체가 생성된 경우, 각각의 객체를 지시함 */
		tt.setA(2);
		int get = tt.getA();
		System.out.println(get);	// 2
	}
}
```

## ② 생성자에서 다른 생성자를 호출하는 This

> 클래스에 생성자가 여러 개 있을 때 생성자에서 다른 생성자를 호출할 때 this 사용 가능

### 생성자 호출 this

> this를 사용하여 생성자를 호출하는 코드 이전에 다른 코드 작성 불가
>
> 기본 생성자에서 생성이 완료되는 것이 아니라
> this를 사용해 다른 생성자를 호출하므로, this가 가장 먼저 와야 함
>
> *→ 클래스 생성이 완료되지 않은 시점에 다른 코드가 있다면 오류 발생*
> *Constructor call muse be the first statement in a constructor*

```java
public class CnstCall {
	String name;
	int age;

	CnstCall() {
		this("김덕배", 22);
	}

	CnstCall(String name, int age) {
		this.name = name;
		this.age = age;
		System.out.println("이름: " + name + ", 나이:" + age);
	}

	public static void main(String[] args) {
		CnstCall cc = new CnstCall();
         // 이름: 김덕배, 나이:22
	}

}
```

*※ 생성자 호출시 호출된 생성자의 모든 코드가 실행됨*

---

다음 주 수업 

1. this 추가
2. 배열
3. 상속_오버라이딩(상속 클래스에서 피상속 클래스에서 작성된 메소드를 재정의 하는 것)
4. 추상클래스
5. 인터페이스