# 200128

# 복습

## 생성자 기능

1. 멤버변수의 초기화 설정
2. 자기 클래스 내부의 또 다른 메서드(생성자) 호출 가능

### This_생성자 호출

> this()를 사용하며 매개변수는 호출하고자 하는 생성자에 따라 다름

---

# JAVA 메모리 구조

## Method Area(= Static Area)

> JVM이 읽어들인 클래스와 인터페이스에 대한 런타임 상수 풀,
> 멤버 변수(Instance 변수), 클래스 변수(Static 변수), 생성자, 메소드 등을 저장하는 공간

- 프로그램이 시작되면 가장 먼저 메모리에 올라오는 부분
  → main() 메소드가 가장 먼저 메모리에 올라감
- 정적 변수, 정적 메소드 선언시 static영역에 할당됨
  → 과도하게 사용시 메모리가 낭비되거나 메모리에 과부하가 걸릴 수 있음

## Heap

> 프로그램에서 사용하는 동적 메모리(dynamic memory) 공간

- new 연산자로 객체 생성시 객체가 저장되는 공간
- ex) Car sonata = new Car();
  sonata 변수는 스택 메모리에 할당되며,
  sonata에는 Car 클래스의 인스턴스가 생성된 힙 메모리의 주소가 대입됨
  (즉, 스택에 저장된 sonata 변수가 힙에 저장된 인스턴스를 가리키게 됨)

| Stack  |   →→→→→   |         Heap          |
| :----: | :-------: | :-------------------: |
| sonata | → → → → → | Car 클래스의 인스턴스 |

## Stack

> 자료가 상자처럼 쌓이는 자료 구조를 말함
> 마지막에 추가된 자료부터 순서대로 꺼내서 사용할 수 있으며
> LIFO(Last In First Out) 구조라고 부름

- 지역변수가 저장되는 영역이며, 한쪽은 막혀있고 한 쪽은 열려있는 구조
- 메소드가 호출될 때 메모리에 할당되는 영역
  메소드의 매개변수와 메소드 내부의 지역변수가 임시로 저장됨
- 메소드를 호출할 때마다 각각의 스택프레임(해당 메소드만을 위한 공간) 생성
- 메소드 호출시 먼저 사용되는 변수가 아래쪽부터 저장되며
  메소드 호출이 끝나면 마지막에 저장된 것부터 해제됨 
- ex) int clacSum(int kor, int eng, int mat){
  int total = kor + eng + mat;
  return total; }
  kor, eng, mat 매개변수와 total 지역변수가 스택 메모리에 할당됨

| 저장 순서 | 변수  | 해제 순서 |
| :-------: | :---: | :-------: |
|     ④     | total |     ①     |
|     ③     |  mat  |     ②     |
|     ②     |  eng  |     ③     |
|     ①     |  kor  |     ④     |

---

# Static 정적 변수 & 정적 메소드

## 정적 변수(=Class 변수)

> 변수 앞에 static을 작성해서 사용하며,
> 정적 변수는 객체를 생성하지 않아도 메모리에 할당됨
>
> 변하지 않으면서 프로그램 전체에서 공유하고자 하는 변수가 필요할 때 사용

### 사용례_정적 변수 / 인스턴스 변수 비교

```java
public class StaticVariable {
	
    // 정적 변수 index 선언
	static int index = 0;
    
    // 인스턴스 변수(멤버 변수) insIndex 선언
    int insIndex = 0;
	
    // index의 값을 1씩 증가시키는 메소드 생성
	public void upIndex() {
		index += 1;
	}
    
    // insIndex의 값을 1씩 증가시키는 메소드 생성
    public void upInsIndex() {
		insIndex += 1;
	}
    
    // insIndex의 값을 반환하는 get() 메소드 생성
    public int getIns() {
		return insIndex;
	}
    
	public static void main(String[] args) {
		
         // StaticVariable 클래스의 sv1 객체 생성
		StaticVariable sv1 = new StaticVariable();
		sv1.upIndex();	// sv1 객체에서 index 값 + 1
         sv1.upInsIndex();	// sv1 객체에서 insIndex 값 + 1
         int insIndex1 = sv1.getIns();	// sv1의 insIndex 값을 insIndex1 변수에 저장
		
         // StaticVariable 클래스의 sv2 객체 생성
		StaticVariable sv2 = new StaticVariable();
		sv2.upIndex();	// sv2 객체에서 index 값 + 1
         sv2.upInsIndex();	// sv2 객체에서 insIndex 값 + 1
         int insIndex2 = sv2.getIns();	// sv2의 insIndex 값을 insIndex2 변수에 저장
		
         // 정적 변수 index 값 출력
		System.out.println(index); // 2
		
         // 인스턴스 변수 insIndex 값 출력
         System.out.println(insIndex1);	// 1
		System.out.println(insIndex2); // 1
    }

}
```

*※ 정적 변수 index의 값은 2가 출력된 반면, 인스턴스 변수는 각각의 객체에 속하는 멤버 변수이기 때문에*
*insIndex1, insIndex2의 값은 각각 1이 출력됨*

## 정적 메소드(=Class 메소드)

> 메소드 앞에 static을 작성해서 사용,
> 정적 메소드 또한 객체를 생성하지 않아도 메모리에 할당됨
>
> ***※ static 메소드는 인스턴스 변수(멤버 변수)에 접근할 수 없음***

*※ '정적'이 아닌 변수, 메소드는 인스턴스(일반) 변수, 메소드라고 함*

### 정적 메소드 / 일반 메소드 차이

|                         정적 메소드                          |                         일반 메소드                          |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| 객체를 생성하지 않고 메소드 호출 가능<br />[클래스명.정적메소드명(~)] | 객체를 생성해야 메소드 호출 가능<br />[객체명.일반메소드명(~)] |
| 바로 메모리에 올라가기 때문에 지속적으로 메모리 공간을 차지함 |         객체를 생성할 때 4byte의 메모리 공간이 필요          |
|                        기본적인 기능                         |                         특수한 기능                          |

*※ 좋은 프로그램을 작성하기 위해서는 정적 메소드와 일반 메소드를 적절하게 사용해야 함*

### 사용례_정적 메소드 & 일반 메소드

> 점수 합계, 평균 계산 프로그램

```java
public class MethodEx {
	// 과목 점수, 정적 메소드를 사용하기 위해서는 정적 변수가 필요함
	static int kor = 89;
	static int eng = 78;
	static int mat = 56;

	// 총점 계산 메소드, 정적 메소드
	static int calcSum() {
		int sum = kor + eng + mat;
		return sum;
	}

	// 일반 메소드
	// 평균 계산 메소드, 과목 수 : 3개
	double calcAvg(int tot) {
		return (double) ((double) tot / 3);
	}

	public static void main(String[] args) {
		// 정적 메소드 사용, 클래스명.메소드명(~)
		int result = MethodEx.calcSum();
		System.out.println(result);		// 223
     	 
         // 일반 메소드 사용, 객체 생성 → 객체명.메소드명(~)
         MethodEx me = new MethodEx();
		double avgResult = me.calcAvg(result);
		System.out.println(avgResult);	// 74.33333...
	}
}
```

## Math 메소드

> **java.lang.Math**
> 자바의 lang 패키지 안에 있는 Math 클래스에 기본적인 수학 메소드들이 저장되어 있음
>
> 정적 메소드이기 때문에 객체를 따로 생성하지 않고 Math.메소드명()으로 사용 가능

### 사용례

```java
public class MathTest {
	public static void main(String[] args) {
		int abs = -500;
         // 삼항 연산자로 절댓값 계산
		abs = (abs < 0)? -abs : abs;
		System.out.println(abs);	// 500
		
         // Math 클래스의 abs 메소드로 절댓값 계산
		abs = Math.abs(-2500);
		System.out.println(abs);	// 2500
        
         // Math 클래스의 max 메소드로 최댓값 계산
         int max = Math.max(43, 95);
		System.out.println(max);	// 95
	}
}
```

*※ API문서 참조 단축키 : 클래스 이름을 쓰고 클래스 내부에 커서를 옮긴 뒤 Shift + F2 입력*
*API에 대해 많이 알면 보다 편리하게 프로그램을 작성할 수 있음*

---

# Array 배열

> 같은 타입(자료형)의 여러 변수를 하나의 대표적인 변수로 묶어주는 것
>
> ↔ 클래스: 다른 타입의 여러 변수를 하나의 대표적인 변수로 묶어주는 것(C 언어에서의 구조체) + 메소드

## 배열 특성

- 많은 양의 데이터를 다룰 때 유용함
  *↔ 변수의 양이 많아지면 관리하기가 어려움*
- 배열의 각 요소는 서로 연속적임
  0부터 시작하는 인덱스번호로 구분
- 변수가 메모리에 연속적으로 저장되기 때문에 처리속도가 향상됨
  *↔ 기본적으로 변수는 메모리에 무작위로 할당됨*
- **참조형(=객체형, 클래스형) 자료형**임
  참조형 자료형에는 Class, Array, Interface 등이 포함됨
- **자동 초기화**
  일반 변수는 반드시 값을 초기화해야 하지만, 배열은 자동으로 초기값이 설정됨
  int → 0, double → 0.0, float → 0.0f, boolean → false

## 배열 종류

1. 고정 배열: 크기가 처음부터 정해져 있는 배열
   배열의 크기를 늘이거나 줄일 수 없음, 기본적인 배열
2. 가변 배열(동적 배열): 크기가 입력받은 데이터의 양에 따라 늘어나거나 줄어들 수 있음
   → ArrayList 컬렉션

## 차원에 따른 배열 종류

- 1차원 배열 : 데이터가 선처럼 일렬로 연속적으로 저장되어 있는 배열
- 2차원 배열 : 데이터가 표와 같이 면으로 저장되어 있는 배열
  배열의 요소가 배열인 경우
- 3차원 배열 : 데이터가 정육면체처럼 입체적으로 저장되어 있는 배열
  배열의 요소가 배열이고 그 배열의 요소가 배열인 경우

*※ 2차원 배열까지는 사용할 수 있어야 함*

## 형식

```java
자료형 배열명[] = new 자료형[개수];
// 자료형[] 배열명 으로도 작성 가능

// 배열을 생성하면서 값 초기화
자료형[] 배열명 = {값1, 값2, 값3,,,,};
```

## 기본 구조

```java
public class ArgTest {
						// args라는 이름의 String형 배열이 매개변수로 main()메소드에 전달됨
	public static void main(String[] args) {
        
		// 배열 생성
		int[] suArray = new int[4];
        
         // 배열 값 저장
		suArray[0] = 1;
		suArray[1] = 2;
		suArray[2] = 3;
        
         // 배열 값 출력
		System.out.println(suArray[0]);	// 1
		System.out.println(suArray[1]);	// 2
		System.out.println(suArray[2]);	// 3
        
         // 자동 초기화로 인해서 0이 저장되어 있음
         System.out.println(suArray[3]); // 0
        
         // 배열도 객체이기 때문에 주소값이 출력됨
		System.out.println(suArray);  // [I@15db9742
	}

}
```

## 가변 배열_Eclipse 활용

> Eclipse의 변수 설정을 사용해서 배열의 크기를 조정
>
> 상단 메뉴 Run → Run Configurations → Java Application에서 클래스 선택 
> → Aruguments 탭 → Program aruguments에 변수 입력
>
> 변수 입력 형식: 변수1 변수2 변수3
>  → 각각의 변수를 띄어쓰기로 구분함
>
> 설정한 변수는 main()메소드에 매개변수로 전달됨 

```java
public class ArgTest4 {
						// String 배열 x를 매개변수로 main()에 전달, 변수: 1 2 3 
	public static void main(String[] x) {
		
         // 합계를 구할 변수
		int sum;
        
         // 배열 x의 요소들을 각각 str1 ~ str3 변수에 저장
		String str1 = x[0];
		String str2 = x[1];
		String str3 = x[2];
		
         // 각각의 변수에 저장된 값 출력
		System.out.println("str1: " + str1);	// str1: 1
		System.out.println("str2: " + str2);	// str2: 2
		System.out.println("str3: " + str3);	// str3: 3
		
         // String은 int로 강제 형변환 할 수 없기 때문에 integer.parseInt() 메소드 사용 
		int int1 = Integer.parseInt(str1);
		int int2 = Integer.parseInt(str2);
		int int3 = Integer.parseInt(str3);
		 
         // int로 변경한 값들을 sum에 더함
		sum = int1 + int2 + int3;
        
         // sum 출력
		System.out.println("합계: " + sum);	// 합계: 6
	}

}
```

## Integer.parseInt() & Integer.toString()

> Integer 클래스에 내장되어 있는 메소드 parseInt()는 매개변수로 주어진 String 형태의 숫자를 int로 반환,
> toString() 메소드는 매개변수로 주어진 int 형의 숫자를 String으로 반환

```java
public class CheckType {
	// 생성자 함수를 이용해서 자료형 확인, 자료형에 따른 문구가 출력되도록 함
	CheckType(String a){
		System.out.println(a + "의 자료형은 String입니다!");
	}
	
	CheckType(int b){
		System.out.println(b + "의 자료형은 Int입니다!");
	}

	public static void main(String[] x) {
		// int형 숫자를 String형 문자열로 형변환
		int fromInt = 10;
		String toString = Integer.toString(fromInt);
		CheckType ct1 = new CheckType(toString);
		// 10의 자료형은 String입니다!
		
         // String형 문자열을 int형 숫자로 형변환
		String fromString = "20";
		int toInt = Integer.parseInt(fromString);
		CheckType ct2 = new CheckType(toInt);
		// 20의 자료형은 Int입니다!
		
	}

}
```

*※ Java에는 JavaScript에서의 typeof()같은 메소드가 없기 때문에 생성자를 이용해서 자료형을 확인해 볼 수 있음*

---

# 배열 활용

## 사용례_for문 활용

> 배열은 같은 자료형의 여러 값을 모아둔 것이기 때문에 for문과 자주 사용됨
>
> 배열의 인덱스를 통해 데이터를 제어할 필요가 있을 때는 for문을 사용하는 것이 유용함

```java
public class ArgTest {

	public static void main(String[] args) {
		// 10개의 int형 데이터를 갖는 배열 arrayTest 선언
		int[] arrayTest = new int[10];
        
         // for문을 이용해서 arrayTest에 10 ~ 100의 값을 저장
		for (int i = 0; i < 10; i++) {
			arrayTest[i] = (i + 1) * 10;
		}
        
         // for문으로 배열 각각의 값을 출력
		for (int i = 0; i < arrayTest.length; i++) {
			System.out.println(arrayTest[i] + "\t");	// \t: tab만큼의 공백을 뜻함
		}
         // 10	20	30	40	50	60	70	80	90	100
	}

}
```

*※ **array.length** : array 배열의 원소 개수(길이) 반환*

## 확장 for문 (향상된 for문)

> 배열 내의 모든 값을 순회하는 for문의 향상된 형태
>
> 배열의 모든 요소를 스캔하는 과정에서 인덱스 자체의 값이 필요하지 않을 때는 확장 for문이 유용함

### 형식

```java
for([배열 자료형][변수명]:[배열명] or [컬렉션 객체명]){
    // 각각의 변수에 적용할 Java Code;
    // 변수는 배열 내의 각각의 값을 뜻함
}
```

### 사용례

> for문 활용에서 다룬 예제를 확장 for문으로 바꿔서 적용

```java
public class ArgTest {

	public static void main(String[] args) {
		int[] arrayTest = new int[10];
		for (int i = 0; i < 10; i++) {
			arrayTest[i] = (i + 1) * 10;
		}
        
         // 확장 for문
		for(int num:arrayTest) {
			System.out.print(num + "\t");
		}
		// 10	20	30	40	50	60	70	80	90	100	
	}

}

```

## 사용례_Scanner 활용

```java
package j200128;

// Scanner 클래스 import
import java.util.Scanner;

// 과목별 점수를 입력받아서 성적을 처리하는 프로그램
public class ArgTest3Sum {

	public static void main(String[] args) {

		// 과목 이름을 저장한 subject 배열 생성
		String[] subject = { "현대철학", "중세철학", "고대철학", "존재와 시간", "소유와 존재" };
        
		// 과목 점수를 저장할 score 배열 생성
		int[] score = new int[5];
		
		// 합계 sum, 평균 avg 초기화
		int sum = 0;
		double avg = 0.0;
		
		// Scanner 클래스를 이용해서 표준입력으로 문자열을 입력받는 sc 객체 생성
		Scanner sc = new Scanner(System.in);

		// 배열에 각각의 점수를 입력받고, 점수의 합계를 계산
		for (int i = 0; i < score.length; i++) {
			System.out.println("[" + subject[i] + "]" + " 점수를 입력하세요");
			score[i] = sc.nextInt();
			sum += score[i];
		}
		
		// 평균 계산: 점수 총합을 과목 수로 나눔, double형으로 형변환 해주어야 소수점이 표현됨
		avg = (double) sum / (double) score.length;
		
		// 과목마다 점수를 출력하는 for문
		for(int i = 0; i<subject.length; i++) {
			System.out.println(subject[i] + " 점수: " + score[i]);
		}
		
		// 총합과 평균 계산
		System.out.println("총합: " + sum);
		System.out.println("평균: " + avg);
        
         // 결과
         /*
         [현대철학] 점수를 입력하세요
         88
         [중세철학] 점수를 입력하세요
         98
         [고대철학] 점수를 입력하세요
         66
         [존재와 시간] 점수를 입력하세요
         100
         [소유와 존재] 점수를 입력하세요
         29
         현대철학 점수: 88
         중세철학 점수: 98
         고대철학 점수: 66
         존재와 시간 점수: 100
         소유와 존재 점수: 29
         총합: 381
         평균: 76.2
         */
	}

}
```

---

# Scanner

> Java.util 패키지에 있는 입력 클래스
>
> 문자뿐만 아니라 정수, 실수 등 다른 자료형도 읽을 수 있음
>
> 콘솔 화면 및 파일, 문자열을 생성자의 매개변수로 받아 자료를 읽어 올 수 있음

## Scanner 대표 생성자

| 생성자                        | 설명                                                         |
| :---------------------------- | ------------------------------------------------------------ |
| *Scanner(File source)*        | 파일을 매개변수로 받아 Scanner 생성                          |
| *Scanner(InputStream source)* | 바이트 스트림을 매개변수로 받아 Scanner 생성<br />InputStream Source: 간단하게 키보드라고 할 수 있음 |
| *Scanner(String source)*      | String을 매개변수로 받아 Scanner 생성                        |

*※ Scanner(System.in): 표준 입력(콘솔 입력)으로부터 자료를 읽어 들이는 Scanner 생성*
*System.in은 InputStream source의 매개변수임*

## Scanner Method

| 메소드         | 설명                                      |
| -------------- | ----------------------------------------- |
| *next()*       | 문자열 String을 ' '(띄어쓰기) 단위로 읽음 |
| *nextLine()*   | 문자열 String을 줄 단위로 읽음            |
| *nextInt()*    | int 자료형을 읽음                         |
| *nextDouble()* | double 자료형을 읽음                      |

## 사용법

```java
// 다른 패키지에 있는 클래스를 사용하고자 할 때는 반드시 import문을 작성해야 함
import java.util.Scanner;

public class ArgTest3 {
	
	public static void main(String[] args) {
         // Scanner 클래스를 이용해서 표준입력으로 문자열을 입력 받는 sc 객체 생성
		Scanner sc = new Scanner(System.in);
		        
         // 입력된 문자열을 str 변수에 저장
         System.out.println("문자를 입력하세요");
		String str = sc.next();
		System.out.println("입력받은 문자: " + str);	// 안녕하세요!
		
		// 입력된 정수 값을 integer 변수에 저장
         System.out.println("정수를 입력하세요");
		int integer = sc.nextInt();
		System.out.println("입력받은 정수: " + integer);	// 34
		
		// 입력된 실수 값을 dbl 변수에 저장
         System.out.println("실수를 입력하세요");
		double dbl = sc.nextDouble();
		System.out.println("입력받은 실수: " + dbl);	// 22.14
	}

}
```

*※ next()메소드로 숫자를 입력받으면 문자열로 취급됨*

*※ 자동 import 단축키 : Ctrl + Shift + O*

---

# API 문서 참조하는 방법

1. 새로운 클래스를 찾으면 생성자 먼저 확인
2. 메소드 확인

# 내일 공부

1. 2차원 배열
2. 가변 배열
3. API 참조
4. 상속의 개요, 이점
5. 상속 오버라이딩