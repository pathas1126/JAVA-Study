# 200207

---

# 복습

1. 자료형 상관없이 문자열 저장, FileOutputStream(영어, 한글 일부),  FileWriter(한글)
2. 자료형에 맞게 저장 DataInput/OutputStream
3. 객체 직렬화: 객체(메모리에 저장된 위치) -> 파일로 저장 또는 네트워크 전송

### BufferdReader Method

| 메소드                                    | 설명                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| *int read()*                              | BufferedReader 클래스 일반 메소드, 문자 하나를 읽어 들임<br />문자를 0~65535의 정수로 읽어 들이며 읽을 문자가 없는 경우 -1 리턴 |
| *int read(char[] cbuf, int off, int len)* | BufferedReader 클래스 일반 메소드<br />문자 배열 cbuf의 off인덱스부터 len 개수만큼의 문자를 정수로 읽어 들임<br />문자가 없는 경우 -1 리턴 |
| *String readLine()*                       | BufferdReader 클래스 일반 메소드<br />입력된 텍스트를 줄 단위('\n')로 읽어 들임<br />읽어 들일 문자가 없어지면 'null' 반환 |
| *void close()*                            | BufferedReader 클래스 일반 메소드<br />스트림 사용 후 메모리에서 스트림을 해제할 때 사용 |

---

# Serialization 직렬화

> 인스턴스의 어느 순간 상태를 그대로 저장하거나 네트워크를 통해 전송하는 것

- 클래스의 인스턴스가 생성되면 인스턴스의 상태, 즉 인스턴스 변수 값은 계속 변화함
- 직렬화로 인스턴스 내용을 연속 스트림으로 만듬
- 스트림으로 만들어야 파일에 쓰거나 네트워크로 전송 가능
- 직렬화 하고자 하는 클래스에서 반드시 Serializable 인터페이스를 구현해야 함
- 직렬화시 모든 유형의 객체를 저장해야 하기 때문에 **Object 클래스형**으로 저장됨

## Deserialization 역직렬화

> 저장된 내용이나 전송받은 내용을 다시 복원하는 것

- 역직렬화를 할 때 클래스 정보가 존재하지 않을 수도 있으므로
  ClassNotFoundException 예외도 처리해야함
- Object 클래스형으로 읽어 들인 객체를
  저장할 클래스 자료형에 맞게 형 변환(Downcasting) 해야 함

## ObjectInput / OutputStream

> 직렬화를 도와주는 자바의 보조 스트림

### 생성자

| 생성자                                 | 설명                                                   |
| -------------------------------------- | ------------------------------------------------------ |
| *ObjectInputStream(InputStream in)*    | InputStream을 매개변수로 받아 ObjectInputStream 생성   |
| *ObjectOutputStream(OutputStream out)* | OutputStream을 매개변수로 받아 ObjectOutputStream 생성 |

### 메소드

| 메소드                         | 설명                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| *Object readObject()*          | ObjectInputStream 클래스 일반 메소드<br />객체 데이터를 스트림으로 불러올 때 사용 |
| *void writeObject(Object obj)* | ObjectOutputStream 클래스 일반 메소드<br />객체 데이터를 외부로 전송할 때 사용 |

## Serializable 인터페이스

> 직렬화는 인스턴스 내용이 외부로 유출되는 것이므로 프로그래머가
> 직렬화를 하겠다는 의도를 표시해야 하는데, 이 때 구현해야 하는 인터페이스

- Marker Interface (마커 인터페이스)
  다른 기능은 없고 해당 클래스를 직렬화하겠다는 의사만 명시하는 인터페이스
- 추상 메소드가 없는 인터페이스
  오버라이딩을 하지 않아도 됨(할 수 없음)

### 형식

```java
class Person implements Serializable {
    // Java Code
}
```

## transient 예약어

> 직렬화 / 역직렬화 과정에서 제외하고자 하는 변수 앞에 작성하는 예약어
>
> 사전적 의미: '일시적인, 일시적으로 머무르는'

- 직렬화 될 수 없는 클래스(ex. Socket)가 인스턴스 변수로 있는 경우에 사용
- 직렬화를 원치 않는 변수에 사용
- transient 예약어를 사용한 변수에는 그 자료형의 기본 값이 저장됨
  ex) 객체 자료형의 경우 null 값이 저장됨

### 형식

```java
transient 자료형 변수명;
// transient String name;
```

*※ name 변수에 null 값이 저장됨*

## 예제

> Person 클래스 객체를 파일로 저장했다가 다시 불러옴

```java
package j200207;

import java.io.*;

// 직렬화 객체의 클래스는 반드시 Serializable 인터페이스를 구현해야 함
class Person implements Serializable {
	String name;
	int age;
	String addr;
    // gender 변수는 직렬화 과정에서 제외함
	transient String gender;
}

public class ObjectTest {
    
    // Exception 하나로도 처리 가능
	public static void main(String[] args) throws IOException, ClassNotFoundException {

		// Person 객체 생성
		Person p = new Person();

		// p 객체 변수 초기화
		p.name = "홍길동";
		p.age = 34;
		p.addr = "경기도 광명시";
		p.gender = "남자";

		// 객체 주소 출력
		System.out.println(p);	// j200207.Person@15db9742

		// p 객체 name, gender 변수 값 출력
		System.out.println(p.name);		// 홍길동
		System.out.println(p.gender);	// 남자

		// 한글이 있지만 객체를 저장하기 때문에 FileOutputStream 사용
		ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("object.txt"));

		// p 객체를 파일에 작성
		oos.writeObject(p);

		// 스트림 사용 후 메모리 해제
		oos.close();
	
        // 파일을 불러오는데 객체 자료형에 맞게 불러오도록 하는 스트림 객체 생성
		ObjectInputStream ois = new ObjectInputStream(new FileInputStream("object.txt"));

		// 모든 유형의 객체를 저장해야 하기 때문에 Object 클래스형으로 저장됨
		Object pr = ois.readObject();

		// pr 객체가 Person 클래스의 인스턴스인지 확인
		System.out.println(pr instanceof Person);	// true
		System.out.println(pr);		// j200207.Person@3b07d329

		// pr 객체를 Person 자료형의 pp 객체로 형 변환(Downcasting)
		Person pp = (Person) pr;

		// pp 객체 주소 출력
		System.out.println(pp);		// j200207.Person@3b07d329

		// pp 객체 name 변수 값 출력
		System.out.println(pp.name);	// 홍길동

		// pp 객체 gender 변수 값 출력
		System.out.println(pp.gender);	// null

		// 스트림 사용 후 메모리 해제
		ois.close();

	}

}
```

---

# File 클래스

> 파일이라는 개념을 추상화한 클래스

- 파일에 대한 입출력은 기반 스트림으로 수행
- 파일 자체의 경로나 정보를 알 수 있고 파일 생성 및 삭제 가능

## 주요 생성자

| 생성자                  | 설명                                 |
| ----------------------- | ------------------------------------ |
| *File(String pathname)* | pathname을 매개변수로 받아 파일 생성 |

## 메소드

| 메소드                     | 설명                                                         |
| -------------------------- | ------------------------------------------------------------ |
| *boolean createNewFile()*  | pathname으로 생성된 File 객체를 실제 파일로 생성<br />파일이 성공적으로 생성되면 true 반환<br />동일한 파일명의 파일이 있는 경우 false 반환 |
| *boolean isFile()*         | 해당 파일이 정상적인 파일인 경우에 true 반환                 |
| *boolean isDirectory()*    | 해당 파일이 정상적인 폴더인 경우 true 반환                   |
| *String getName()*         | 해당 파일 또는 폴더의 이름을 반환                            |
| *String getAbsolutePath()* | 파일 또는 폴더의 절대 경로 반환                              |
| *String getPath()*         | 파일 또는 폴더 경로를 문자열로 반환<br />파일 객체가 생성될 때 매개변수로 받은 path가 반환됨 |
| *boolean canRead()*        | 해당 파일을 읽을 수 있는 경우에 true 반환                    |
| *boolean canWrite()*       | 해당 파일에 쓸 수 있는 경우에 true 반환                      |
| *delete()*                 | 파일 또는 폴더를 제거하고 성공적으로 제거된 경우 true 반환   |

## 예제

```java
package j200207;

import java.io.File;
import java.io.IOException;

public class FileTest {

	public static void main(String[] args) throws IOException {
		// 해당 경로/파일명.확장자를 매개변수로 받아서 File 객체 생성
		File f = new File("fileTest.txt");

		// f 객체를 비어있는 파일로 생성
		Boolean b = f.createNewFile();
		System.out.println(b);		// true

		// f가 실제 파일인지 확인
		Boolean b2 = f.isFile();
		System.out.println(b2);		// false

		// f가 폴더인지 확인
		Boolean b3 = f.isDirectory();
		System.out.println(b3);		// true

		// 파일의 이름을 가져 옴
		String name = f.getName();
		System.out.println(name);	// fileTest.txt

		// 파일의 절대 경로를 가져옴
		String absPath = f.getAbsolutePath();
		System.out.println(absPath);
		// C:\webtest\3.java\JAVA-Study\200207\fileTest.txt

		// 객체 생성시 지정된 파일 경로를 가져옴
		String path = f.getPath();
		System.out.println(path);	//fileTest.txt

		// 파일을 읽을 수 있는지 확인
		Boolean b4 = f.canRead();
		System.out.println(b4);		// true

		// 파일에 쓸 수 있는지 확인
		Boolean b5 = f.canWrite();
		System.out.println(b5);		// true

		// 파일 삭제
		Boolean b6 = f.delete();
		System.out.println(b6);		// true

	}

}
```



---

# Wrapper Class

> 기본 자료형의 값을 객체 형태로 만들어서 제공하는 클래스
>
> 기본 자료형을 감쌌다는 의미로 Wrapper 클래스라고 함

- 기본 자료형의 첫글자만 대문자로 쓰면 Wrapper 클래스가 됨
  ***단, int는 Integer로 char는 Character로 작성***
- String은 원래 참조 자료형이기 때문에 Wrapper 클래스가 아님(필요 없음)

## 형식

```java
Wrapper 변수명 = new Wrapper(값);
// Double d = new Double(123.45);

Wrapper 변수명 = 값;
// Double d = 123.45; 바로 초기화하는 것도 가능
```

## AutoBoxing & UnBoxing

> Wrapper 클래스를 기본 자료형으로 직접 형 변환하지 않아도
> 컴파일러가 연산이 가능하도록 형 변환을 해주는 것

- 오토박싱: 기본형을 객체형으로 바꾸는 것
- 언박싱: 객체형을 기본형으로 꺼내는 것

## 예제

```java
package j200207;

public class BoxingTest {

	public static void main(String[] args) {
		Integer num1 = new Integer(123); // Integer 클래스 num1 선언
		int num2 = 200;		// int 자료형 num2 선언
		int sum = num1 + num2; // 언박싱: num1.intValue()로 변환
		Integer num3 = num2; // 오토박싱: Integer.valueOf(num2) 로 변환
	}

}
```

---

# Collection  Framework 컬렉션 프레임워크

> 필요한 자료 구조를 미리 구현하여 java.util 패키지에서 제공하는 것
>
> 컬렉션 프레임 워크에는 여러 인터페이스가 정의되어 있고
> 인터페이스를 구현한 클래스가 있음

- 전체 구조는 Collection 인터페이스와 Map 인터페이스를 기반으로 이루어짐
- Collection 인터페이스는 하나의 자료를 모아서 관리하는 데 필요한 기능 제공
- Map 인터페이스는 쌍(pair)으로 된 자료들을 관리하는 데 유용한 기능 제공

## Collection 인터페이스

>하나의 자료를 모아서 관리하는 데 필요한 기능을 제공하는 인터페이스
>
>하위에 List 와 Set 인터페이스가 있음

- List: 순차적인 자료를 관리하는 데 사용하는 인터페이스, 중복을 허용함
  ArrayList, Vector, LinkedList, Stack, Queue 등의 구현 클래스들이 있음
- Set: 순서와 상관없이 중복을 허용하지 않음
  아이디처럼 중복되지 않는 객체를 다루는데 사용
  HashSet, TressSet 등의 구현 클래스 존재

### Collection 메소드

> 구현 클래스에서 오버라이딩해야 하는 추상 메소드
>
> 구현 클래스마다 이름이 다른 메소드를 사용하면 기억하기가 어렵기 때문에
> 인터페이스에서 자주 사용될 만한 메소드를 미리 정의해 둠

| 메소드                     | 설명                                                      |
| -------------------------- | --------------------------------------------------------- |
| *boolean add(E e)*         | Collection에 객체를 추가함                                |
| *void clear()*             | Collection의 모든 객체 제거                               |
| *Iterator< E > iterator*   | Collection을 순환할 반복자(iterator) 반환                 |
| *boolean remove(Object o)* | Collection에 매개변수에 해당하는 인스턴스가 존재하면 제거 |
| *int size()*               | Collection에 있는 요소 개수 반환                          |
| *boolean isEmpty()*        | Collection에 데이터가 하나도 들어있지 않다면 true 반환    |
| *Iterator< E > iterator()* | 해당 컬렉션 내부의 요소들을 iterator로 반환               |


## Map 인터페이스

> 쌍(pair)으로 된 자료들을 관리하는 데 유용한 기능을 제공하는 인터페이스

- key - value 쌍으로 데이터 관리
- key 값은 중복될 수 없으며, value 값은 중복 가능 
- 검색용 자료 구조이며, 검색 속도가 가장 빠름
- key 값을 알고 있을 때 value 를 찾기 위한 자료 구조임
- 대표 구현 클래스: HashTable, HashMap, TreeMap

### Map Method

| 메소드                                     | 설명                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| *V put(K key, V value)*                    | key에 해당하는 value 값을 map에 추가                         |
| *V get(K key)*                             | key에 해당하는 value 값 반환                                 |
| *boolean isEmpty()*                        | Map이 비었는지 여부를 반환<br />비어있다면 true 반환         |
| *boolean containsKey(Object key)*          | Map에 해당 key가 있다면 true 반환                            |
| *boolean containsValue(Object value)*      | Map에 해당 value가 있다면 true 반환                          |
| *Set keyset()*                             | key 집합을 Set로 반환, 중복 불가<br />Set은 값의 중복을 허용하지 않음 |
| *Collection values()*                      | value들을 Collection으로 반환<br />중복 허용<br />Iterator 사용시 값들을 Collection 객체로 먼저 보내기 위해 사용<br />*∵ iterator() 메소드가 없음* |
| *V remove(key)*                            | key가 있는 경우 삭제                                         |
| *boolean remove(Object key, Object value)* | key가 있는 경우 key에 해당하는 value가 매개변수와 일치할 때 삭제 |

---

# 제너릭

> 컬렉션에 저장할 객체 자료형을 미리 지정하는 것

## 특징

1. 컬렉션에 지정된 자료형으로만 데이터 저장 가능
   컬렉션에는 객체만 저장 가능하기 때문에 클래스형 및 Wrapper 클래스만 지정 가능
2. 컬렉션 내부의 데이터를 꺼내올 때 일일이 형 변환할 필요가 없어짐
   → 유지보수에 용이

## 형식_< > 연산자

> **< >**: 다이아몬드 연산자라고 하며
> 컬렉션에 저장될 자료형을 <> 안의 클래스형으로 지정함

```java
컬렉션<객체 종류> 컬렉션 객체명 = new 컬렉션<객체 종류>();
// Vector<String> v = new Vector(); → v 에 String 객체만 저장 가능
// 생성자() 앞의 <객체 종류> 는 생략 가능
```

*※ Map 인터페이스 구현 클래스들은 키-값 쌍으로 데이터를 관리하기 때문에*
*2개의 객체 종류 명시 < key 객체 종류1, value 객체 종류2>*

---

# List

> 순차적인 자료를 관리하는 데 사용하는 인터페이스
> 요소의 중복을 허용함

## ArrayList

> 객체 배열을 구현한 클래스
> 컬렉션 인터페이스와 리스트 인터페이스를 구현
>
> 객체 순서를 기반으로 순차적으로 자료를 관리하는 프로그램 구현시 사용

- 요소의 개수에 따라 ArrayList의 크기가 자동으로 조정됨
- 배열의 0번 인덱스부터 순서대로 요소가 저장됨
- 동기화가 제공되지 않음
- 내부적으로 데이터를 배열에서 관리하며 데이터 추가 / 삭제시 임시 배열을 생성해서 데이터를 복사함
- 대량의 자료를 추가 / 삭제하는 경우 그만큼 데이터 복사가 일어나기 때문에 성능이 저하될 수 있음
- 요소마다 인덱스를 가지고 있기 때문에 데이터 검색시에는 유리함

### 생성

```java
ArrayList<E> 배열 이름 = new ArrayList<E>();
```

*※ E: 제너릭 자료형, 해당 자료형의 데이터만 저장될 수 있도록 지정*

### 메소드

| 메소드                           | 설명                                                  |
| -------------------------------- | ----------------------------------------------------- |
| *boolean add(E e)*               | 요소 하나를 배열에 추가, E는 요소의 자료형을 의미함   |
| *void add(int index, E element)* | 배열의 index 위치에 element 요소 삽입                 |
| *int size()*                     | 배열에 저장된 요소의 전체 개수 반환                   |
| *E get(int index)*               | index 위치의 요소 값 반환                             |
| *E set(int index, E element)*    | index 위치의 요소 값을 element로 대체                 |
| *E remove(int index)*            | 배열의 index 위치에 있는 요소 값 제거 후 해당 값 반환 |
| *boolean isEmpty()*              | 배열이 비어 있는지 확인, 비어있다면 true 반환         |

### 예제

```java
package j200207;

import java.util.*;

public class ArrayListTest {

	public static void main(String[] args) {

		// List 구조 내부에 배열이 저장된 구조, 인덱스번호로 구분
		// String 형의 자료만 저장 가능
		ArrayList<String> list = new ArrayList<String>();

		// add(element), list 배열에 값 입력
		// 추가한 데이터는 앞에서부터 순서대로 저장됨
		list.add("포도");
		list.add("딸기");
		System.out.println(list);	// [포도, 딸기]

		// add(index, element), index 1에 "키위" 값 삽입
		list.add(1, "키위");
		System.out.println(list);	// [포도, 키위, 딸기]

		// set(index, element), index 0의 요소를 "복숭아"로 변경
		list.set(0, "복숭아");
		System.out.println(list);	// [복숭아, 키위, 딸기]

		// remove(index), index 2의 요소 삭제
		list.remove(2);
		System.out.println(list);	// [복숭아, 키위]

		// size(), list 내의 요소 개수 반환
		System.out.println(list.size());	// 2

		// get(index), index 위치의 값 반환
		for (int i = 0; i < list.size(); i++) {
			System.out.println(list.get(i));
		}

		// 확장 for문 사용 가능
		for (String s : list) {
			System.out.println(s);
		}
        
         /*
         복숭아
         키위
         */
        
	}

}
```

## LinkedList

> LinkedList에 저장된 각 요소가 다음 요소의 주소 값을 가지는 배열 구조

### ArrayList와의 차이

- 데이터 추가/삭제시 불필요한 데이터 복사가 없기 때문에 데이터 추가/삭제시 유리
  ∵ 이전 요소에서 가르킬 다음 요소의 주소 값만 변경하면 되기 때문
- 데이터 검색시에는 처음부터 요소를 순회해야 하기 때문에 검색시에는 불리

### 메소드

| 메소드                     | 설명                                    |
| -------------------------- | --------------------------------------- |
| *void addFrist(E element)* | element를 리스트의 가장 앞에 삽입       |
| *E removeLast()*           | 리스트 가장 마지막 요소를 삭제하고 반환 |

*※ 기본적인 메소드의 이름 및 기능은 ArrayList와 동일*

## Vector

> ArrayList처럼 배열을 구현한 클래스
>
> 멀티스레드 환경이 아니라면 ArrayList 사용을 권장

### ArrayList와의 차이

- Vector는 동기화를 지원함
- 메모리를 많이 차지함
- 불러오는 속도가 더 느림

### Vector 메소드

| 메소드                                 | 설명                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| *boolean add(E e)*                     | Element(요소)를 벡터의 끝에 추가함                           |
| *void addElement(E obj)*               | 특정 객체를 벡터의 끝에 추가함                               |
| *E elementAt(int index)*               | 해당 인덱스의 요소를 반환함<br />List 인터페이스의 get(int) 메소드와 기능적으로 동일함 |
| *void insertElement(E obj, int index)* | 해당 인덱스에 obj 요소를 삽입, 원래 해당 인덱스에 있던 값부터 인덱스가 뒤로 하나씩 밀림 |
| *void setElement(E obj, int index)*    | 해당 인덱스의 요소를 obj로 대체함(set)                       |

---

# MAP

> key - value쌍(pair)으로 된 자료들을 관리하는 데 유용한 기능을 제공하는 인터페이스

## Hashtable

> Vector와 마찬가지로 멀티스레드를 위한 동기화 제공
>
> 멀티스레드 환경이 아니라면 HashMap을 사용하는 것이 권장됨

## HashMap

> Map 인터페이스 구현 클래스 중 가장 많이 사용하는 클래스

### HashMap 메소드

| 메소드                   | 설명                                                      |
| ------------------------ | --------------------------------------------------------- |
| *V put(K key, V value)*  | Map 인터페이스 객체에 key-value 저장                      |
| *V get(Object key)*      | key 와 짝지어진 value 반환                                |
| *Collection< V > values()* | 해당 map에 포함되어 있는 value들을 Collection view로 반환 |

### 예제

```java
package j200207;

import java.util.*;

public class EnumTest {

	public static void main(String[] args) {
		// HashMap 객체 생성, Integer-String 으로 키-값 저장
		HashMap<Integer, String> h = new HashMap(); 
        
        // put(key, value), 키-값 입력
		h.put(1, "홍길동");
		h.put(2, "서울시 강남구");
		h.put(3, "010-2312-1241");
        System.out.println(h);	// {1=홍길동, 2=서울시 강남구, 3=010-2312-1241}
		
        // get(key), 키에 해당하는 값 반환
		String a = h.get(1);
		System.out.println(a);	// 홍길동
		
	}
}
```



---

# Iterator, Enumeration

> 컬렉션의 구조가 다르다 할지라도
> 공통으로 자료를 검색할 수 있는 기능을 제공하는 인터페이스

- 자료 구조를 A에서 B로 바꾸면 출력문까지 전부 수정해야하는데
  데이터 검색 방식을 표준화함으로써 코드의 재사용이 가능해짐
- 컬렉션 자료형이라면 자료구조에 관계없이 사용가능하지만
  Iterator / Enumeration을 반환하는 메소드가 있는지 확인이 필요함

## Iterator

> 반복자라는 뜻을 가진 인터페이스로 컬렉션에서 자료를 얻어오는데 사용

### Iterator 메소드

| 메소드              | 설명                                                         |
| :------------------ | ------------------------------------------------------------ |
| *boolean hasNext()* | iterator가 요소를 가지고 있다면 true 반환                   |
| *E next()*          | iterator의 다음 요소 반환                                   |
| *void remove()*       | next()가 한 번 호출될 때마다 한 번씩 호출 가능<br />next()에 의해 반환된 요소를 삭제<br />원본에도 영향을 미침 |

### Iterator 반환 메소드가 없는 컬렉션의 경우

1. Collection을 반환하는 메소드를 사용해서 Collection 객체 생성
   ex) HashMap - values();
2. 컬렉션의 iterator() 메소드로 Iterator를 반환해서 Iterator 객체 생성
3. 데이터 조회

## Enumeration

> 하나하나 센다는 뜻을 가진 인터페이스로 Iterator와 동일한 기능을 함

### Enumeration 메소드

> Iterator의 remove()를 제외하고는 유사한 메소드를 가짐

| 메소드                      | 설명                                                         |
| --------------------------- | ------------------------------------------------------------ |
| *boolean hasMoreElements()* | 해당 enumeration에 값이 더 있는지 확인<br />enumeration 객체가 하나 이상의 요소를 갖는다면 true 반환 |
| *E nextElement()*           | enumeration 객체의 다음 요소 반환                            |

## 예제

> 사용법은 유사하기 때문에 Iterator 예제만 다룸

```java
package j200207;

import java.util.*;

public class IteratorTest {

	public static void main(String[] args) {

		// ArrayList 컬렉션 객체 생성
		ArrayList<String> al = new ArrayList();
		al.add("홍길동");
		al.add("이순신");
		al.add("세종대왕");
		System.out.println(al); // [홍길동, 이순신, 세종대왕]

		// Iterator 객체 생성
		Iterator<String> it = al.iterator();

		// Iterator 요소 조회
		while (it.hasNext()) {
			System.out.println(it.next());
		}
		// 홍길동 이순신 세종대왕

		// HashMap 컬렉션 객체 생성
		HashMap<Integer, String> hm = new HashMap();
		hm.put(1, "강감찬");
		hm.put(2, "유성룡");
		hm.put(3, "정약용");
		System.out.println(hm); // {1=강감찬, 2=유성룡, 3=정약용}

		/* HashMap에는 Iterator를 반환하는 메소드가 없기 때문에
		values() 메소드로 Collection view를 반환해서 컬렉션 객체를 생성한 뒤에
		컬렉션의 iterator()메소드로 Iterator를 반환해서 객체 생성 */
		Collection<String> cl = hm.values();
		Iterator ir = cl.iterator();

		System.out.println(ir.next()); // 강감찬
		ir.remove();
		System.out.println(ir.next()); // 유성룡
		ir.remove();
		System.out.println(ir.next()); // 정약용

		for (int i = 1; i < 4; i++) {
			System.out.println(hm.get(i));
		}
		// null null 정약용
	}

}
```

