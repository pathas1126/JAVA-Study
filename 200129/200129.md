# 200129

## 앞으로의 진도

1. 상속(상속과 생성자와의 관계, super, super())
2. ★★추상클래스, 인터페이스 => 스프링 설계 // 자바 문법은  거의 종료
3. 윈도우 프로그래밍(Swing) => 이벤트 처리 (문법적으로 중요)
4. ★★★객체형변환 => ★★★예외 처리 => ★★입출력 => ★★★★컬렉션 => 쓰레드(동기화 처리)
5. 네트워크
6. ★★★★JDBC Programming

보강계획: 추상화 => 인터페이스

---

# API 문서 참조 방법

1. java.lang 패키지를 기본으로 찾아봄 : 자바 프로그램의 기본적인 내용이 들어 있음<br/>
   String(문자열), Integer(정수), StringBuffer, Character(문자)
2. 찾고자하는 메소드의 성격을 파악<br/>
   매개변수 유무, 개수, 자료형, 반환형<br/>
   String, Integer, Double(실수)
3. 메소드가 일반 메소드인지 정적 메소드인지 파악<br/>
   정적메소드 : 클래스명.메소드명()<br/>
   일반메소드 : 객체 생성 => 객체명.일반메소드명() => 생성자 참조
4. 매개변수가 있고, 반환형이 없는 메소드 : 보통 set으로 시작
   void setXXX(~), 저장목적으로 많이 사용

---

# String Method

> 기본적으로 많이 사용되는 String 클래스 메소드 정리

| 메소드                              | 설명                                                         |
| :---------------------------------- | ------------------------------------------------------------ |
| *substring(start index)*            | String 클래스의 일반 메소드, 객체명.substring()으로 사용하며,<br />시작 인덱스부터 마지막 인덱스까지의 문자열을 추출함<br />문자열 시작 인데스: 0 |
| *substring(start index, end index)* | 시작 인덱스부터 지정한 끝 인덱스까지의 문자열을 추출하는 메소드<br />시작 인덱스의 문자열은 포함되며, 끝 인덱스의 문자열은 제외됨<br />즉, 끝 인덱스 전 문자열까지 추출 |
| *toUpperCase()*                     | String 클래스의 일반 메소드, 객체명.toUpperCase()로 사용하며,<br />문자열의 모든 알파벳을 대문자로 반환함 |
| *toLowerCase()*                     | 위의 메소드와 반대로 문자열의 모든 알파벳을 소문자로 반환    |
| *trim()*                            | String 클래스의 일반 메소드, 객체명.trim()으로 사용,<br />문자열 양 옆의 불필요한 공백들을 전부 제거한 문자열 반환 |
| *String.valueOf(parameter)*         | String 클래스의 정적 메소드,<br />매개변수로 주어진 객체의 값을 String 문자열로 반환<br />다양한 오버로딩 메소드를 가지고 있기 때문에 기본 자료형은 모두 매개변수로 전달 가능 |

## 사용례

```java
public class ArgTestConvert {
		// String 변수 선언
		String string = "Hello, My Friend!";
		String beforeTrim = "           Hello, My Friend!           ";
		int fromInt = 1234;
    
     	 // substring(startIndex), 7번째 인덱스부터 마지막 인덱스까지 문자열 추출
		String subString1 = string.substring(7);
    
    	 // substring(startIndex, endIndex), 7번째부터 11번째 직전 문자열까지 추출
		String subString2 = string.substring(7, 11);
    
    	 // toUpperCase(), string의 모든 문자열을 대문자로 반환
		String toUpper = string.toUpperCase();
    
    	 // toLowerCase(), string의 모든 문자열을 소문자로 반환
		String toLower = string.toLowerCase();
    
    	 // trim(), beforeTrim 문자열 양 옆의 불필요한 공백 제거
		String trim = beforeTrim.trim();
    
    	 // String.valueOf(), fromInt값을 String으로 변환해서 반환 
		String valueOf = String.valueOf(fromInt);
		
		System.out.println(subString1);		// My Friend!
		System.out.println(subString2);		// My F
		System.out.println(toUpper);		// HELLO, MY FRIEND!
		System.out.println(toLower);		// hello, my friend!
		System.out.println(trim);			// Hello, My Friend!
		System.out.println(valueOf);		// 1234
	}

}
```

---

# Ellipsis (...)

> 매개변수로 들어오는 값의 개수와 상관 없이 메소드가 기능하도록 해주는 매개변수

- (...) 매개변수로 전달되는 인자들의 자료형은 반드시 같아야 함
- (...) 앞에 매개변수가 있는 경우,
  인자들이 앞에 있는 매개변수부터 하나씩 순서대로 전달되고
  나머지 인자들이 (...)으로 전달됨
- 가변배열 형태의 매개변수임

*※ **Argument 인자:** 매개변수로 전달된 실질적인 값*

## 형식

```java
(자료형 ... 매개변수명)
```

## 사용례_확장 for문 활용

```java
package j200129;

public class VarArgTest {
    
    // ... 매개변수를 사용
	public void print(String... names) {
        // 가변배열의 형태로 매개변수를 받아오기 때문에 확장 for문 사용 가능
		for (String name : names) {
			System.out.print(name + ", ");
		}
         // 줄바꿈
		System.out.println();
	}

	public static void main(String[] args) {
		// 객체 생성
         VarArgTest vat = new VarArgTest();
	
         // 출력, 인자들의 자료형은 반드시 같아야 함
		vat.print("홍길동");
		vat.print("홍길동", "이순신");
		vat.print("홍길동", "이순신", "유성룡");
		vat.print("홍길동", "이순신", "유성룡", "강감찬");
		vat.print("홍길동", "이순신", "유성룡", "강감찬", "이도");
		/*
		인자들이 주어지면 names 배열은 다음과 같이 동작함
		String names[] = {"홍길동"}
		String names[] = {"홍길동", "이순신"}
		String names[] = {"홍길동", "이순신", "유성룡"}
		...
		===== 결과 =====
		홍길동, 
		홍길동, 이순신, 
		홍길동, 이순신, 유성룡, 
		홍길동, 이순신, 유성룡, 강감찬, 
		홍길동, 이순신, 유성룡, 강감찬, 이도, 
		*/
	}
    
}
```

---

# 다차원 배열_이차원 배열

> 배열의 리스트가 배열로 이루어진 표(면)의 형태를 갖는 배열
>
> 배열의 첫 번째 리스트를 **행**이라고 하고,
> 각 행에 해당하는 배열을 **열**이라고 함

## 고정배열

> 행과 열의 개수가 정해져 있는 배열

```java
자료형 [][] 배열명 = new 자료형[개수][개수]
```

## 가변배열

> 행의 개수는 정해져 있지만, 열의 개수는 정해져 있지 않은 배열
>
> *행의 개수가 정해져 있지 않은 배열은 생성할 수 없음*

```java
자료형 [][] 배열명 = new 자료형[개수][]
```

## 초기화

```java
// 배열을 생성한 후 초기화 하는 경우, 불편하기 때문에 자주 사용되지 않음
자료형 [][] 배열명 = new 자료형[2][2]
배열명[0][0] = 값1, 배열명[0][1] = 값2, 배열명[1][0] = 값3, 배열명[1][1] = 값4

// 생성과 동시에 초기화, 동시에 초기화하는 경우 행/열 개수를 임의로 설정 가능
자료형 [][] 배열명 = {{값1, 값2, 값3},{값4, 값5}, {값7},,,}
```

## 사용례

```java
package j200129;

public class DoubleArray {

	public static void main(String[] args) {
		// int형 이차원 배열 array 생성 및 초기화
		int[][] array = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
		
         // array 배열의 행 값 출력
		for (int i = 0; i < array.length; i++) {
			System.out.println(array[i]);
		}
         //  행의 주소값이 출력됨 -> 열의 리스트가 저장되어 있는 주소를 알려줌
		/*
		[I@15db9742
		[I@6d06d69c
		[I@7852e922
         */
        
         // array 배열의 행에 저장된 각각의 열 값 출력
		for (int i = 0; i < array.length; i++) {
			for (int j = 0; j < array[i].length; j++) {
				System.out.println("array2[" + i + "][" + j + "]: " + array[i][j]);
			}
         }
         /*
         array2[0][0]: 1
         array2[0][1]: 2
         array2[0][2]: 3
         array2[1][0]: 4
         array2[1][1]: 5
         array2[1][2]: 6
         array2[2][0]: 7
         array2[2][1]: 8
         array2[2][2]: 9
         */
	}

}
```

## 확장 for문_이차원 배열

### 형식

```java
for(1차원 배열 자료형 배열명[]:2차원 배열명){
    for(1차원 배열 자료형 변수명: 1차원 배열명){
        // Java Code;
    }
}
```

### 사용례

```java
package j200129;

public class DoubleArray {

	public static void main(String[] args) {

		int[][] array = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };

		for (int tmp[] : array) { // 2차원 배열 내의 각각의 행을 임시로 1차원 배열 tmp[]에 할당
			for (int val : tmp) { // 1차원 배열 tmp[]의 각각의 요소를 임시로 변수 val에 할당
				System.out.print(val + "\t");
			}
			System.out.println();
		}
        /*
        1	2	3	
        4	5	6	
        7	8	9	
        */
	}

}
```

---

# Array of Objects 객체 배열

> 참조 자료형으로 선언하는 배열로, 같은 참조 자료형의 객체만 저장된 배열
>
> 기본적인 사용 방법은 배열과 동일함

## 사용례

```java
package j200129;

public class ArrayOfObject {

	// 멤버 변수 선언
	String name;
	int age;
	char gender;

	// 생성자
	ArrayOfObject(String name, int age, char gender) {
		this.name = name;
		this.age = age;
		this.gender = gender;
	}

	// 정보 출력 메소드
	void printInfo() {
		System.out.println("이름: " + name + ", 나이: " + age + ", 성별: " + gender);
	}

	public static void main(String[] args) {
         // ArrayOfObject 자료형 객체 배열 선언, 배열의 크기는 3
		ArrayOfObject[] aoo = new ArrayOfObject[3];
        
		// 객체 배열 값 초기화, 배열의 요소가 객체이기 때문에 생성자를 이용해서 값을 초기화
		aoo[0] = new ArrayOfObject("이순신", 33, '남');
		aoo[1] = new ArrayOfObject("유성룡", 34, '남');
		aoo[2] = new ArrayOfObject("권율", 32, '남');

		// 객체 배열에 저장된 각각의 값 출력
		for (int i = 0; i < aoo.length; i++) {
			aoo[i].printInfo();
		}
         /*
         이름: 이순신, 나이: 33, 성별: 남
         이름: 유성룡, 나이: 34, 성별: 남
         이름: 권율, 나이: 32, 성별: 남
         */
		
         // 객체 배열 내 각 요소의 주소값 출력, 객체가 저장되어 있기 때문에 각각의 주소값이 출력됨
		for (int i = 0; i < aoo.length; i++) {
			System.out.println(aoo[i]);
		}
         /*
         j200129.ArrayOfObject@15db9742
         j200129.ArrayOfObject@6d06d69c
         j200129.ArrayOfObject@7852e922
         */
        
		// 첫 번째 요소의 이름만 출력해보기
		System.out.println("이름: " + aoo[0].name);	// 이름: 이순신
	}

}
```

*※ **객체배열명[index].멤버변수***
*객체 배열에는 객체의 정보가 담겨 있기 때문에 '요소.멤버변수'로 객체의 멤버변수에 접근할 수 있음*

---

# Inheritance 상속

## 개요

> 객체 지향 프로그래밍의 중요한 특징 중 하나
> 일반적으로 무언가를 물려받는다는 의미

- 자식 클래스가 부모 클래스의 멤버 변수와 메소드를 물려받는 것
  → B 클래스가 A 클래스를 상속받으면 B 클래스는 A 클래스의 멤버 변수와 메소드 사용 가능
- 객체 지향 프로그램의 기반이 되는 기술
- 복사와 유사

## 형식

```java
class 자식 클래스 extends 부모 클래스
```

*※ 자식 클래스는 **sub class**, 부모 클래스는 **super class** 라고 함*

## 장점

- 부모 클래스의 멤버변수와 메소드를 그대로 사용하기 때문에 재사용성이 높음
- 코드의 양을 줄이고 개발시간을 단축할 수 있음

## 단점

부모 클래스로부터 물려받은 메소드를 자식 클래스에서 그대로 사용하게 되기 때문에
자식 클래스의 내용에 맞지 않게 메소드가 동작하는 경우가 발생

## 특징

- 생성자는 상속 불가
  구조적인 문제 때문에 그런데, 이에 대해서는 나중에 설명 예정
- private으로 선언된 멤버변수와 메소드는 상속 불가
  접근제어자 private은 멤버변수와 메소드가 해당 클래스 내에서만 사용 가능하도록 함
- 다중 상속 불가, 동시에 여러 부모로부터 상속을 받을 수는 없음
  프로그램이 복잡해지기 때문에 다중 상속을 제한함, 단일 상속만 가능
  class 자식 extends 부모1, 부모2 (X)
  class 자식 extends 부모1, calss 자식 extends 부모2 (O)
- 누적 상속 가능
  A클래스를 상속받는 B클래스를 C클래스가 상속받을 수 있음
  멤버 변수와 메소드 개수가 증가하며 기능이 많아짐 

## Overriding 메소드 재정의

> 자바에서 다형성을 지원하는 방법 중 하나
>
> 부모 클래스로부터 상속받은 메소드를 같은 이름으로 재정의하는 것을 말함
>
> 상속의 단점을 보완할 수 있는 기법

사용례에서 상속과 함께 사용법을 다룸

## Class 관계

### has-a 관계

> "A는 B를 가지고 있다"의 관계가 성립되는 포함 관계
>
> 철수가 지갑을 가지고 있다. (O)
> 지갑이 철수를 가지고 있다. (X)
> → 위와 같은 관계를 has-a 관계라고 함

- A 클래스에서 B 클래스를 상속받는 것이 아니라 내부에 인스턴스(객체)를 따로 생성하는 것
  → 포함 관계 성립
- 여러 클래스를 하나로 합쳐서 만들기 때문에 조각 프로그래밍이 편해짐

 ### is-a 관계

> "A는 B이다"의 관계가 성립되는 상속(extends) 관계
>
> 팀장은 그 회사의 직원이다.(O)
> 직원은 그 회사의 팀장이다.(X)
> → 위와 같은 관계를 is-a 관계라고 함

- 상속을 사용하려면 반드시 논리적으로 is-a 관계가 성립되어야 함
- 부모클래스를 수정하면 자식클래스에 영향을 주지만 자식클래스를 수정해도 부모클래스에는 영향을 미치지 못함
- 자식클래스를 인스턴스(객체)로 생성하면 부모클래스의 멤버까지 포함한 인스턴스가 생성됨

## 사용례_상속 & Overriding & 객체 배열

> 예제 시나리오
> 신입 사원 → 부서배치(개발 1과)
> 팀장 → 개발 1과
> 급여: 연봉제 + 보너스(사원: 150%, 팀장: 300%)

### Employee.java

```java
package j200129;

// 신입 사원 클래스
public class Employee {

	// 공통 멤버 변수
	String name;
	int age;
	String gender;
	String addr;
	long salary;

	// 생성자 오버로딩
	public Employee(){}

	public Employee(String name, int age, String gender, String addr, long salary) {
		this.name = name;
		this.age = age;
		this.gender = gender;
		this.addr = addr;
		this.salary = salary;
	}

	// 보너스를 반환하는 메소드, 사원 보너스: 150%
	double bonus() {
		return salary * 1.5;
	}

	// 저장되어 있는 값을 그대로 출력하는 메소드
	void display() {
		System.out.println("===직원 정보===");
		System.out.println("이름: " + name);
		System.out.println("나이: " + age);
		System.out.println("성별: " + gender);
		System.out.println("주소: " + addr);
		System.out.println("급여: " + salary);
		// 메소드 내부에서 동일 클래스 내의 일반 메소드 호출
		System.out.println("보너스: " + bonus());
	}

	public static void main(String[] args) {

	}

}
```

*※ Eclipse 생성자 자동 작성 : Source → Generate Constructor using Fields*

### Company.java

```java
package j200129;

// 팀장 이상 직원들의 정보를 저장할 클래스, Employee 클래스 상속
class Manager extends Employee {
	/* 
	Employee 클래스로부터 상속 받은 멤버 변수
	String name;
	int age;
	String gender;
	String addr;
	long salary;
	 */
	
    // Manager 클래스의 멤버 변수
	String department;

	// 객체 배열 멤버 변수, 신입 사원들의 정보가 담긴 Employee 자료형 배열
	Employee sub[];

	// 생성자, 생성자는 상속받을 수 없기 때문에 직접 작성 해야 함
	public Manager() {}

	public Manager(String name, int age, String gender, 
         long salary, String addr, String department) {
		
         this.name = name;
		this.age = age;
		this.gender = gender;
		this.salary = salary;
		this.addr = addr;
		this.department = department;
	}

	// Employee 클래스의 bonus() 메소드 Overriding(재정의), ∵팀장 보너스: 300%
	double bonus() {
		return salary * 3.0;
	}
}

public class Company {

	public static void main(String[] args) {
		// 신입 사원 3명 채용
		Employee e1 = new Employee("홍길동", 23, "남", "서울시 강북구", 1500);
		Employee e2 = new Employee("이순신", 25, "여", "경기도 광주시", 2100);
		Employee e3 = new Employee("강감찬", 22, "남", "대전시 중구", 1700);

		// 팀장 채용
		Manager m1 = new Manager("이세종", 42, "남", 3000, "서울시 강남구", "개발 1과");
		
         // 신입 사원 → 부서 배치, m1.sub 이라는 Employee객체 배열 생성
         // Manager의 멤버 변수인 sub[] 객체 배열의 크기를 지정하고 초기화
         m1.sub = new Employee[3];
		m1.sub[0] = e1;
		m1.sub[1] = e2;
		m1.sub[2] = e3;

		// 사원 정보 출력, Employee를 상속받았기 때문에 Employee의 display() 메소드 사용 가능
		System.out.println("====신입 사원====");
		for (int i = 0; i < m1.sub.length; i++) {
			m1.sub[i].display();
		}

		// 팀장 출력
		System.out.println("====팀장====");
		m1.display();

	}
}
```

### 결과

```java
/*
====신입 사원====
===직원 정보===
이름: 홍길동
나이: 23
성별: 남
주소: 서울시 강북구
급여: 1500
보너스: 2250.0
===직원 정보===
이름: 이순신
나이: 25
성별: 여
주소: 경기도 광주시
급여: 2100
보너스: 3150.0
===직원 정보===
이름: 강감찬
나이: 22
성별: 남
주소: 대전시 중구
급여: 1700
보너스: 2550.0
====팀장====
===직원 정보===
이름: 이세종
나이: 42
성별: 남
주소: 서울시 강남구
급여: 3000
보너스: 9000.0
*/
```

---

# 예습

1. 상속-생성자 관계
2. super, super(매개변수)
3. 접근지정자 → 캡슐화 마무리
4. 추상클래스
5. 인터페이스
6. 그래픽: Swing(인터페이스 활용), 이벤트 처리
7. 객체 형변환
